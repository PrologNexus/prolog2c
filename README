

	???



* Introduction

  This is ???, a compiler for the Prolog[1] programming language. ???
  compiles a single source file into C, that can be subsequently
  compiled with a C compiler to an executable. The generated code is
  platform-independent and should be portable to a wide range of
  machines and operating systems. No other dependencies exist, only a
  C compiler is required. The generated executables are fairly small
  and can be embedded in existing applications.

  ??? has no support for dynamic predicates, or for calling
  user-constructed goals - all code must be statically visible.  An
  interactive interpreter is available and can be used as a library in
  compiled Prolog code, but interpreted code will not be visible to
  compiled code. Loading (consulting) code at runtime is not possible
  and manipulating the clause-database with assert/retract will have
  no effect on the running program.

  Performance is reasonable, in microbencjhmarks roughly comparable to
  systems like SWI-Prolog[2], but will not be able to compete with
  such mature Prolog implementations for larger programs. Basic
  clause-indexing on the type of the first argument of a predicates is
  provided and tail-call optimization is performed in most cases.

  The dialect of Prolog implemented should be sufficient for usual
  Prolog programming. Basic ISO and Edinburgh system predicates and
  control structures are available, but no support for constraint
  programming or coroutining. 

* Building and installation

  The compiler itself is written in Prolog and must be pre-compiled to
  C before it can be used. In the distribution archive that contains
  the file your are currently reading, pre-compiled code for the
  compiler and interpreter are included, so all that remains to be
  done is to compile these using make(1):

    make

  A C compiler with support for C99, including some GNU extensions is
  required, both gcc[4] and clang[5] have been successfully tested.
  You can edit the variables at the top of the makefile to choose
  a different compiler or different compilation options.

  Several builtin predicates are actually implemented in Prolog and
  reside in separate library files in the "lib" directory. You can
  install the compiler and interpreter-binaries wherever you like, but
  to find the libraries the compiler must be able to locate the
  library directory. This can be done either by passing 

    -I <library-directory>

  as additional command-line options when compiling a source file, or
  by setting the environment variable "PC_INCLUDE_PATH" to a list of
  directories to be searched, separated by ":" (which should not
  include the "lib/" part - i.e. the path(s) should point to the
  location in which the "lib" directory resides.)

* Usage

  Simply invoke the compiler with the source file to be compiled:

    pc <FILENAME>

  The compiler understands the following command-line options:

    -h                      show some usage information.
    -v                      show clauses as they are compiled.
    -i                      show intermediate code produced instead 
    			    of generating a C file.
    -o FILENAME             specify output-file name (defaults to
       			    the name of the source file, with the
			    file-extension replaced by ".c")
    -I DIRECTORY            add DIRECTORY to the current include-
       			    path.
    -q                      do not show any output while compiling.

  Code compiled with the compiler must be passed to a C compiler

    gcc -std=gnu99 -I. <program>.c -o <program> -lm

  - Platform-specific issues

    Linux:

      On Linux the "librt" must be linked by adding "-lrt" to the
      C compiler invocation given above.

  It is advisable to add some optimization options to improve the
  performance of the compiled executables, recommended are typically
  
    -O2 -fomit-frame-pointer -fno-strict-aliasing -fwrapv

  The latter two will prevent the C compiler from taking advantage of
  some unintuitive interpretations of the C language and should be
  used when optimizations are enabled for code produced by the Prolog
  compiler.

* Interpreter

  The interpreter can be run interactively by simply starting it, or
  can run and execute a Prolog source file, given on the command-line.
  Giving the command-line option "-t", execution starts in "trace"
  mode, which shows how predicates are called, exit, fail or
  re-execute during backtracking. The interpreter has all
  library-predicates included and does not need to have access to the
  library directory.

  In contrast to the compiler, the clause-database represents the
  program that is currently executing and manipulations of the database
  will influence running code. The effect of asserting or retracting
  clauses for predicates that currently execute is undefined.

  Note that the interpreter is a simple meta-circular evaluator and is
  thus rather slow. DCG grammars are currently not supported in
  interpreted code.

* Debugging and error messages

  There are no debugging-facilities besides a "trace" mode, which
  writes information about predicate-calls, -exits, -fails and redo's
  during execution to stderr. You can enable this trace mode by
  compiling the generated C code with the "-DTRACE" option given to
  the C compiler. Once compiled in trace mode you can run the
  executable with "-:d" to produce actual the execution-trace.

  The compiler does very little error-reporting, mostly to simplify
  the implementation. Syntactical errors will produce a parser error,
  with some rough indication about the place where the problem
  occurred. Runtime-errors will throw an exception, which can be
  caught by user code using catch/3. 

  Calls to undefined procedures will result in linker errors during
  compilation to C, so e.g.

    main :- foo.

  when compiled to C and given to the C compiler will result in
  something similar to

    x.c: In function ‘main’:
    x.c:20:1: error: label ‘___foo$0’ used but not defined

  Here the name of the predicate ("foo") appears in "mangled" form,
  that is, converted into a valid C identifier.

* Builtin predicates

  DCG rules of the form "HEAD --> BODY" are supported in compiled code.

  - Control structures

    GOAL, GOAL                    Conjunction [ISO]

    GOAL; GOAL                    Disjunction [ISO]

    GOAL1 -> GOAL2	          "If-then" [ISO]

    !	    		          "Cut" [ISO]

    \+ GOAL	            	  "Not" [ISO]

    repeat    			  Always succeeds [ISO]

    findall(?T, +GOAL, -R)	  Unify R with the list of all T for goal GOAL 
    		       		  [ISO]

    forall(+GOAL1, +GOAL2)        True if GOAL2 unifies for all solutions of 
    		   		  GOAL1.

    catch(+GOAL1, ?BALL, +GOAL2)  Invoke GOAL1 and, if an exception occurs
    		  	 	  during its execution that unifies with
				  BALL, invokes GOAL2 and continues [ISO]

    throw(BALL)			  Throws exception BALL [ISO]

    The goals must be complete, callable terms, merely passing
    variables containing callable terms is not sufficient.

  - Equality and comparison predicates

    X = Y			  Unifies X with Y [ISO]

    X \= Y                        Succeeds if X does not unify with Y [ISO]

    X == Y			  Succeeds if X is identical to Y [ISO]

    X \== Y			  Succeeds if X is not identical to Y [ISO]

    X @< Y			  X is ordered below Y [ISO]

    X @> Y			  X is ordered above Y [ISO]

    X @=< Y			  X is ordered below Y or is identical [ISO]

    X @>= Y			  X is ordered above Y or is identical [ISO]

  - Conversion-predicates

    atom_codes(?X, ?Y)		  Unifies X with the atom constructed from the
    		   		  character-codes in the list Y or vice versa
				  [ISO]

    number_codes(?X, ?Y)	  Unifies X with the number constructed from the
    		   		  character-codes in the list Y or vice versa
				  [ISO]

    name(?X, ?Y)		  Unifies X with the atom or number constructed
    	     			  from the character codes in the list Y or 
				  vice versa.

  - Term-construction and deconstruction predicates

    arg(+INDEX, +TERM, ?ARG) 	  ARG is the INDEXth argument of TERM [ISO]

    functor(?X, ?Y, ?Z)		  Unifies Y with the name and Z with the arity
    		    		  of the term X. If X is a variable, constructs
				  a term of arity Z with the name Y where the
				  terms arguments are all fresh unbound variables
				  [ISO]

    copy_term(?X, ?Y)		  Unifies X with a copy of the term Y or vice
    		  		  versa [ISO]

    ?X =.. ?Y			  Deconstructs term X into a list of its name
       	   			  and arguments, or constructs a term from
				  a list ("univ") [ISO]

  - Type-testing predicates

    atom(+X)			  True if X is an atom [ISO]

    atomic(+X)			  True if X is an atom or a number [ISO]

    compound(+X)		  True if X is a non-atomic structure [ISO]

    db_reference(+X)		  True if X is a database-reference

    float(+X)			  True if X is a floating-point number [ISO]

    integer(+X)			  True if X is an integral number [ISO]

    nonvar(+X)			  True if X is not an unbound variable [ISO]

    number(+X)			  True if X is an integer or floating-point 
    				  number [ISO]

    stream(+X)			  True if X is an input/output stream

    var(+X)			  True if X is an unbound variable [ISO]

  - Input/Output predicates
  
    current_error_output(-X)	  Unifies X with the current error output
    				  stream.

    display(+X)			  Display X on the current output stream,
    				  note that lists are printed in list-
				  notation.

    nl				  Writes the newline character on the current
    				  output stream [ISO]

    peek(+X)			  Reads the next character from the current
    				  input-stream and unifies the character code
				  with X (-1 if end of file is reached). The
				  character is not removed from the input 
				  stream.

    put(+X)			  Writes the character with the code X to the
    				  current output-stream. X may be an integer
				  or an atom.

    flush			  Flushes pending but unwritten output in the
    				  current output-stream.

    append(+FILE)		  Opens FILE in "append" mode and makes it 
    				  the current output-stream. FILE may be an
				  atom or a list of character codes (a string).

    get(-X)			  Unifies X with the code of the next non-
    				  whitespace character in the current input-
				  stream.

    get0(-X)			  Unifies X with the code of the next character
    				  in the current input-stream.

    read(-X)			  Reads the next term from the current input-
    				  stream and unifies it with X [ISO]

    read(-X, -Y)		  Similar to read/1, but unifies Y with a list
    	     			  of "ATOM=VARIABLE" terms, with an element for
				  each variable (different from "_") in the
				  read term.

    see(+X)			  Sets the current input-stream to X, which may
    				  be a stream or a filename (an atom or a list
				  of character codes.)

    seeing(-X)			  Unifies X with the current input-stream.

    seen			  Closes the current input-stream (if it is not
    				  the default input-stream) and sets the current
				  input-stream to the default one.

    skip(+X)			  Reads characters from the current input-stream
    				  until a character that unifies with X is read.

    tab(+N)                       Writes N spaces to the current output stream.

    tell(+X)			  Sets the current output-stream to X, which may
    				  be a stream or a filename.

    telling(-X)			  Unifies X with the current output-stream.

    told			  Closes the current output-stream (if it is not
    				  the default output-stream) and sets the current
				  output-stream to the default one.

    write(+X)			  Writes X to the current-output stream, using
    				  operator notation, if possible.

    writeq(+X)			  Writes X to the current-output stream, using
    				  operator-notation, if possible and quotes
				  atoms that would need to be quoted on reading.

    Note that all streams opened via see/1 and tell/1 are opened in binary 
    mode.

  - Database access predicates

    abolish(+PI)		  Removes all clauses in the clause-database
    				  under the given predicate-indicator, which
				  may be an atom, a term of the form NAME/ARITY
				  or a list of predicate-indicators [ISO]

    asserta(+CLAUSE)
    asserta(+CLAUSE, -REF)	  Inserts clause X into the clause-database,
    		     		  before any existing clauses with the same
				  name and arity, optionally unifiying REF 
				  with a DB-reference to the inserted clause 
				  [ISO]

    assertz(+CLAUSE)
    assertz(+CLAUSE, -REF)	  Inserts clause X into the clause-database,
    		     		  after existing clauses with the same name
				  and arity, optionally unifiying REF with a 
				  DB-reference to the inserted clause [ISO]

    clause(+X, ?Y)		  
    clause(+X, ?Y, -REF)	  Unifies X and Y with the head and body of
    	       	   		  matching clauses in the clause-database, 
				  optionally unifying REF with a database-
				  reference to the matched clause [ISO].

    erase(+X)			  Erases the entry with the database-reference
    				  X in the clause- or record-database.

    recorda(+X, -Y)
    recorda(+X, -Y, -REF)	  Inserts term Y under key X in the record
    		    		  database, before any existing terms for
				  the same key, optionally unifying REF with
				  a database-reference to the added term.

    recordz(+X, -Y)
    recordz(+X, -Y, -REF)	  Inserts term Y under key X in the record
    		    		  database, after any existing terms for
				  the same key, optionally unifying REF with
				  a database-reference to the added term.

    recorded(+X, -Y)
    recorded(+X, -Y, -REF)	  Unifies Y with the terms found in the 
    		     		  record-database under the key X, optionally
				  unifying REF with a database-reference to
				  the found term.

    retract(+X)			  Removes matching clauses in the clause-database
    				  and unifies X with the matgched clause [ISO]

    Note that clauses in the clause-database have no effect on compiled 
    programs.

  - Arithmetic predicates

    X < Y			  True if X is numerically less than Y [ISO]

    X > Y			  True if X is numerically greater than Y [ISO]

    X =< Y			  True if X is numerically less than or equal to
      	 			  Y [ISO]

    X >= Y			  True if X is numerically greater than or equal
      	 			  to Y [ISO]

    X =:= Y			  True if X is numerically equal to Y [ISO]

    X =\= Y			  True if X is not numerically equal to Y [ISO]

    -X is Y			  Unifies X with the result of evaluating 
       	  			  expression Y [ISO]

    Note that variables in expressions must contain numerical values.
    Expressions in variables are not evaluated (as is normally
    required by ISO Prolog).

  - Arithmetic operators

    - X				  Negation [ISO]

    \ X				  Bitwise complement [ISO]

    X + Y			  Addition [ISO]

    X - Y			  Subtraction [ISO]

    X * Y			  Multiplication [ISO]

    X / Y			  Division (always returns float) [ISO]

    X // Y			  Integer division [ISO]

    X \\ Y			  Integer remainder

    X /\ Y			  Bitwise and [ISO]

    X \/ Y			  Bitwise or [ISO]

    X >> Y			  Bit-shift right [ISO]

    X << Y			  Bit-shift left [ISO]

    X ** Y			  Exponentation [ISO]

    abs(X)			  Absolute value [ISO]

    atan(X)			  Arcustangens [ISO]

    ceiling(X)			  Next larger integer [ISO]

    clock			  Current time in seconds, starting from
    				  some unspecified point in time.

    cos(X)			  Cosine [ISO]

    exp(X)			  Exponential function [ISO]

    float(X)			  Convert to float [ISO]

    float_fractional_part(X)	  Fractional component [ISO]

    float_integer_part(X)	  Integer component [ISO]

    floor(X)			  Next smaller integer [ISO] 

    log(X)			  Natural logarithm [ISO]

    random(X)			  Random integer between  0 and X (exclusive).

    round(X)			  Round to nearest integer [ISO]

    sign(X)			  Sign of value [ISO]

    sin(X)			  Sine [ISO]	

    sqrt(X)			  Square-root [ISO]

    truncate(X)			  Truncate to integer [ISO]

    X xor Y			  Bitwise xor

  - Operating-system interaction

    command_line_arguments(-X)	  Unifies X with a list of the command-line
    				  arguments passed to the currently running
				  program. The list does not include the
				  program name.

    exists_file(+X)		  True, if the file with the name X (an atom
    				  or string) exists.

    getenv(+X, -Y)		  Unifies Y with the value of the environment
    	       			  variable named by X, which may be an atom
				  or a string.

    getpid(-X)			  Unifies X with the process-id of the currently
    				  running process.

    halt			  
    halt(+CODE)			  Terminates the currently running program
    				  and returns to the operating system with exit
				  code X (defaults to 0).

    sleep(+X)			  Waits X seconds.

    shell(+CMD)			  
    shell(+CMD, -STATUS)	  Executes the shell-command CMD (which should
    				  be an atom or a string) and unifies STATUS
				  with the return status (exit code) of the
				  shell after running the command. If STATUS
				  is not given, shell/1 fails when the command
				  returns with an exit-status that is not 0.

  - Set operations

    intersection(+SET1, +SET2, -SET3)
    			          SET3 is the intersection of the sets SET1 and
				  SET2.

    select(?X, ?SET1, ?SET2)      SET2 is SET1 with element X removed.

    subtract(+SET1, +SET2, -SET3)
    		    	          SET3 is SET1 with the elements of SET2 removed.

    union(+SET1, +SET2, -SET3)    SET3 is the union of the sets SET1 and SET2.

  - Predicates on ordered sets

    list_to_ord_set(+LIST, -SET)  SET is LIST converted to an ordered set.

    ord_disjoint(+SET1, +SET2)    True if X and Y have no common elements.

    ord_insert(+SET1, +X, -SET2	  True if X inserted into SET1 gives SET2.

    ord_intersect(+SET1, +SET2)   True if sets have some elements in common.

    ord_intersect(+SET1, +SET2, -SET3) 
    			 	  SET3 is the intersection of SET1 and SET2.

    ord_memberchk(+X, +SET)	  Unifies X with the first element of SET -
    		      		  this predicate only produces one solution.

    ord_seteq(+SET1, +SET2)	  True if sets are equal.

    ord_subset(+SET1, +SET2)	  True if SET1 is a subset of SET2.

    ord_subtract(+SET1, +SET2, -SET3)
    			          Subtract SET2 from SET1, giving SET3.

    ord_symdiff(+SET1, +SET2, -SET3)
    		       	          SET3 is the symmetric difference of SET1
				  and SET2 (i.e. it is the union without the
				  intersection.)

    ord_union(+SET1, +SET2, -SET3)
    		     	          SET3 is the union of SET1 and SET2.

  - List operations

    length(?X, ?N)		  N is the length of list X.

    keysort(+SET, -SORTED)	  SORTED is SET, ordered by the first argument
    		  		  of each element (usually -/2).

    merge(+SET1, +SET2, -SET3)    SET3 is the combination of the ordered sets SET1
    		 		  and SET2.

    reverse(?X, ?Y)		  Y is the list X in reverse order.

    sort(+X, -Y)		  Y is the list X in sorted order.

    append(?X, ?Y, ?Z)		  Z is the list Y appended to the list X.

    member(?X, ?Y),		  Unifies X with the members of the list Y.

    memberchk(?X, +Y)		  Like member/2, but produces only one solution.


  - Calling code written in other languages

    foreign_call(CALL)	    	  Invokes a foreign procedure (see below for more
    				  information.)

  - Other predicates

    true			  Always succeeds [ISO]

    fail			  Always fails [ISO]


    garbage_collect		  Triggers a garbage collection on the next
    				  predicate-invocation.


    suspend(?X, ?Y)               Suspends execution in embedded code (see
    				  below for more information about embedding).

    enable_trace(+X)		  Enables "trace" mode in compiled code, starting
    				  at the next call, exit or fail. For this to
				  be effective, the program must be compiled with
				  the "-DTRACE" option.

    compare(-X, ?X, ?Z)		  Compares X and Z and unifies X with one of the
    		    		  atoms '=', '<' or '>', depending on whether
				  Y is identical, ordered below or ordered above
				  Z.

    between(+LOW, +HIGH, ?X)      X is between LOW and HIGH, inclusive.

    current_op(?P, ?A, ?N)        Unifies N with the name of any currently defined
    		       		  operators with precedence P and associativity A.

    op(+P, +A, +N)		  Defines a new operator with name N (an atom),
    	       			  precedence P (an integer between 0 and 1200) and
				  associativity A (one of the atoms 'fx', 'fy', 'xf',
				  'yf', 'xfx', 'xfy' or 'yfx'). N may also be a
				  list of atoms.

    global_ref(NAME, -X)          Unifies X with the current value of the global
    		     		  variable NAME, which must have been previously
				  declared with the "global_variable" directive
				  (see below.)

    global_set(NAME, +X)          Sets the global variable with the name NAME to
    		     		  X. Note that this does not take care of backtracking,
				  use copy_term/2 to preserve X in that case.

  - Predicates that are only available in the interpreter

    trace      	    	     	  Enables "trace" mode that displays goals as	
    				  they are executed.

    call(GOAL)			  Invokes GOAL, which may be directly callable
    				  or a variable containing such a goal.

    consult(FILE)		  Loads clauses in the given file into the
    				  clause-database, erasing all previously
				  stored clauses that have the same name and
				  arity as clauses in the consulted file.
				  If the file has the extension ".pl", then
				  this extension may be omitted.

* Precedence of builtin operators

  | Name             | Associativity | Precedence |
  |------------------+---------------+------------|
  | *                | yfx           |        400 |
  | **               | xfx           |        200 |
  | +                | fy            |        200 |
  | +                | yfx           |        500 |
  | ,                | xfy           |       1000 |
  | -                | fy            |        200 |
  | -                | yfx           |        500 |
  | -->              | xfx           |       1200 |
  | ->               | xfy           |       1050 |
  | /                | yfx           |        400 |
  | //               | yfx           |        400 |
  | /\               | yfx           |        500 |
  | :-               | fx            |       1200 |
  | :-               | xfx           |       1200 |
  | ;                | xfy           |       1100 |
  | <                | xfx           |        700 |
  | <<               | yfx           |        400 |
  | =                | xfx           |        700 |
  | =..              | xfx           |        700 |
  | =:=              | xfx           |        700 |
  | =<               | xfx           |        700 |
  | ==               | xfx           |        700 |
  | =\=              | xfx           |        700 |
  | >                | xfx           |        700 |
  | >=               | xfx           |        700 |
  | >>               | yfx           |        400 |
  | @<               | xfx           |        700 |
  | @=<              | xfx           |        700 |
  | @>               | xfx           |        700 |
  | @>=              | xfx           |        700 |
  | \                | fy            |        200 |
  | \+               | fy            |        900 |
  | \/               | yfx           |        500 |
  | \=               | xfx           |        700 |
  | \==              | xfx           |        700 |
  | \\               | xfy           |        400 |
  | ^                | xfy           |        200 |
  | initialization   | fx            |       1150 |
  | is               | xfx           |        700 |
  | xor              | yfx           |        400 |
  | |                | xfy           |       1105 |

* Directives

  The following directives are available in compiled code and can be
  declared using the usual ":- DIRECTIVE, ... ." syntax:

  global_variable(NAME)      Declares NAME as a global variable, accessible
  			     with global_set/2 and global_ref/2.

  verbatim(CODE)             Include CODE directly in the produced C file.
  			     All code declared in "verbatim" directives
			     will be concatenated and emitted at the start
			     of the generated code, directly after the
			     inclusion of "pc.h".

  The following directives are available in the compiler and interpreter:

  include(FILENAME)          Include the contents of FILENAME at the current
  			     position in the source-code that contains this
			     clause. If the file exists and has the extension
			     ".pl", then the extension may be omitted in the
			     directive.

  initialization GOAL        Declares GOAL to be an initialization goal that
  		 	     will be invoked when a compiled program is
			     started or when a file given to the interpreter
			     on the command-line has been consulted.
			     Several initialization goals may be declared
			     and are invoked in the order in which they appear
			     in the source code.

			     In compiler code, the default initialization goal
			     is main/0.
			     
  op(P, A, N)                Declares an operator - identical to op/3,
  	   		     but done before reading any further clauses.

  pre_initialization(GOAL)   Declares GAOL to be a pre-initialization goal.
  			     This is similar to the "initialization"
			     directive, but pre-initialization goals are
			     run before all normal initialization goals.

* Calling code written in other languages

  To call foreign functions, a single form named "foreign_call" is
  provided. foreign_call/1 takes a structure that names the function
  to be called and holds the arguments to be passed. The function
  should be externally visible, take as many arguments as the
  structure and return an integer, indicating whether the foreign call
  failed (0) or succeeded (1). The arguments are of type "X", a
  generic union type which is either an immediate small integer
  ("fixnum") or a pointer to a non-immediate data object. See "pc.h"
  in the distributed source for more information about the internal
  data layout.

  C code can be embedded in the compiled program using the "verbatim"
  directive. The text given will be emitted directly in the generated
  code.

  Values used from C will only be valid until a garbage collection is
  triggered, which subsequently moves all live data. Therefor
  references to Prolog data will become invalid, unless saved in the
  "global" variables vector", a separate buffer that may be used to
  keep "live" references to heap-allocated data. 
  
  Note that the garbage collector ignores data that is not located in
  the garbage-collected heap, so you can create Prolog data structures
  in native code and pass them to Prolog without problems. You can use
  copy_term/2 to copy static data from native code into dynamically
  allocated data located in the heap (but you must of course free the
  old static data manually).

* Extending the compiler and interpreter

  There are currently no special facilities for this - just add your
  own definitions to "pc.h" when you want to add your own primitives,
  and add a wrapper or reference to a library in "macros.pl". The
  system is intended to be easy to hack and modify and you are
  encouraged to study everything and change or extend things as you
  like. Providing sophisticated foreign-function interfaces or
  interfaces for user-extensions would only make the general
  architecture more complex and error-prone, so it has been decided to
  keep things simple, linear, reduce the number of source files and
  avoid overly clever interfaces. Whether this was successfull, is
  something for you to decide...

* Embedding

  If you compile the C code with the "-DEMBEDDED" option, then the
  program will not contain a "main()" function and can be called as a
  library. The entry-point will have the following prototype:

    extern X prolog(int argc, char *argv[], X arg, int *exit_code);

  The first two arguments pass the command-line (even in embedded
  mode), and should contain at least a single entry (what is normally
  the program name.) You can pass command-line options, including
  runtime options, here as usual. The compiled Prolog code will start
  like any other non-embedded program, until suspend/2 is invoked,
  which passes its first argument to the caller of the "prolog()"
  function (the result). Any re-invocation of "prolog()" will continue
  the execution of the Prolog code at the state where the previous
  execution was suspended, passing on the "arg" value to be unified
  with the second argument of suspend/2.

  All invocations of "prolog()" after the first _must_ pass "0" and
  "NULL" as values for "argc" and "argv".

  Should the program terminate, "exit_code" will be set to the
  exit status of the program, depending on how the program
  terminated execution:

    Reason					Exit code
    -----------------------------------------------------------
    halt/0					0
    halt/1					<code>
    Runtime-error / uncaught exception          EXIT_EXCEPTION
    Normal termination	     			EXIT_SUCCESS
    Initialization goal(s) failed		EXIT_FAILURE

  A second entry-point called "prolog_variables" is also available
  to allow access to entries in the "global variable vector" 
  (mentioned above):

    extern X *prolog_variables(int index);

  This returns a pointer to a slot in the global variables vector,
  which can be set and retrieved. Values in this vector undergo
  garbage collection and change their address after every invocation
  of the Prolog side, but will not be collected and retain their
  identity.

  The name of the "prolog()" entry-point can be changed by redefining
  the ENTRY_POINT_NAME macro when compiling the C code of an embedded
  program. The name of the "prolog_variable()" access function can be
  changes by redefining VARIABLE_ACCESS_NAME.

  The compiled Prolog code is not reentrant or thread-safe.

* Limitations

  call/1 and its variants are not available in the compiler, as are
  setof/3 and bagof/3. Goals passed to catch/2, findall/3, forall/2
  and '\+'/1 must be directly callable.

  Integer numbers are limited to signed integers in a range of 31 bits
  on 32-bit platforms and 63 bits on 64-bit platforms.

  UNICODE is not supported, the system uses 256-bit character codes,
  dependent on the default character set of the environment.

  The system is fairly minimal but robust enough to execute many
  Prolog programs. The compiler does provide very few error
  diagnostics, mainly to keep it simple and straightforward to extend.

  The garbage collector used is a simple Cheney-style[5] copying
  collector and all storage for data-structures constructed at
  run-time is allocated in this GC'd heap. Execution will stop when GC
  occurs - to keep this interruption short it is advisable to reduce
  the amount of memory used.

  Depending on the nature of the executing program,
  memory-requirements may vary accordingly. Currently, the system is
  not overly memory-efficient with respect to choice-points,
  environments and the trail-stack. There is currently too much
  trailing, and the trail does not undergo garbage collection (this
  may be implemented at some stage).

  The data-areas used at run-time are listed here, together with their
  default sizes. You can override the settings by redefining a macro
  when compiling generated C code or by passing the appropriate
  run-time command-line option to the final compiled executable.

  Meaning             Macro                     R/T option      Default
  ----------------------------------------------------------------------
  Heap size           HEAP_SIZE                 -:h<SIZE>    100,000,000
  Heap reserve        HEAP_RESERVE                                    20
  Trail stack         TRAIL_STACK_SIZE          -:T<SIZE>      1,000,000
  Choice-point stack  CHOICE_POINT_STACK_SIZE   -:C<SIZE>     10,000,000
  Environment-stack   ENVIRONMENT_STACK_SIZE    -:E<SIZE>     10,000,000
  Argument-stack      ARGUMENT_STACK_SIZE       -:A<SIZE>     10,000,000

  All sizes are in bytes, with the exception of "heap reserve", which
  is a percentage of the total heap-size, which is kept free to
  simplify heap-exhaustion checks: once the amount of storage
  currently in used exceeds the heap-size minus this percentage, a
  garbage collection is triggered.

* License

  Copyright (c) 2015, Felix L. Winkelmann
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the distribution.
  3. The name of the authors may not be used to endorse or promote products
     derived from this software without specific prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  This code uses a certain amount of code from the freely available DEC10
  Prolog library[3]:

    These files are all in the "public domain" so you can use them
    freely, copy them, incorporate them into programs of your own and
    so forth without payment.  The work of producing them in the first
    place and of organising them as detailed here has been funded over
    the years at Edinburgh University mainly by the Science and
    Engineering Research Council.  Their dissemination has been
    encouraged by the Alvey Special Interest Group: Artificial
    Intelligence.  We would appreciate it if you were to acknowledge
    these bodies when you use or re-distribute any of these files.

* References

  [1] http://en.wikipedia.org/wiki/Prolog
  [2] http://www.swi-prolog.org
  [3] http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/prolog/code/tools/edinbrgh/0.html
  [4] http://gcc.gnu.org
  [5] http://clang.llvm.org
