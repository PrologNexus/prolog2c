NOTES											              -*- Org -*-


* Optimization opportunities
** DONE Check: take advantage of timestamps when binding vars in unify() ?
   - try: when binding two unbound vars, bind the younger one.
   - implemented in branch /bind-younger/ and seems to work, but trail
     reduction is not much.
   - does this help with file:broken-tests/bench_1_5.pl ?
** Singleton variables could get special handling when in argument position
   - unification is a noop, unless nested in another term.
** TODO Implement memberchk/2 as primitive
** writeq/1 could use foreign_call(basic_writeq(X)) for atoms
   - but the name needs to be classified anyway, because of the possibly
     required space in front of it.
** Mode-declarations
   - can probably be used in many ways, but needs more thought.
** TODO Determinacy declarations
   - i.e. ":- determinate(PI)."
   - file:da.pl
   - provide predicate "is_deterministic(EXPR)"
   - add declarations for all library predicates, where appropriate.
   - use determinism-information to find more tailcall-opportunities.
     - propagate mode, depending on called predicate, see:
       compile_ordinary_call in file:compile.pl
** TODO Extend clause indexing
*** Dispatch on atom- or fixnum list via hashing
    - add slot containing hash-code to symbol (created during interning)
    - generate table only for first predicate in list, redo in any of
      the clauses can jump back to dispatch for this block.
** Arithmetic
   - deref all vars just once at start.
   - track types, use unboxed math.
** With some sort of type/groundness analysis many primitives can be rewritten to simpler forms
   - functor, arg, name, '=..', etc.
** Matching term in db could be done in C
*** Unify inside db_find/db_next (properly undwinding trail on failure)
    - handling heap-full case on thawing still makes this ugly.
** TODO current_op/3 needs fast path when operator name is known
   - could use single-bucket db, with unififcation inside
     db_find/db_next (provided, we implement matching in file:pc.h)
** Deterministic goal in condition of if-then-else can drop some of the CP dance
   - same for '\\+'/2
   - fail could actually just perform a jump, perhaps redefine FAIL
     temporarily (or use intermediate macro).
** Analyze program before compiling to pseudo-instructions
   - perform determinacy-analysis for all code.
   - in other words: actually take advantage of having a static whole-program compiler.
* TODO Find proper name
  - Whopper
  - ?-Prolog
* TODO Move repo to bitbucket
* Benchmark results
** Self-compile, 5 times, average of medium 3 runtimes
   - SWI prolog: 1.30s
   - <2015-01-04 Sun>: 1.79s (unoptimized: 2.38s)
   - <2015-01-05 Mon>: 1.71s (smaller data area sizes)
   - <2015-01-08 Thu>: 1.81s (not sure, probably more work done in
     compiler)
   - <2015-01-08 Thu>: 1.83s (additional catcher-slot in CP)
   - <2015-01-16 Fri>: 2.65s (no idea, probably compiler extensions,
     e.g. clause indexing)
** TODO Find a better benchmark
   - because extending the compiler with optimizations will
     necessarily slow it down.
   - run some non-trivial test in interpreter.
* Things to test
** TODO Test on Mac, Windows
   - Port to MSVC
** TODO Run some or all tests with pi
** TODO Test retract-loop
   - file:tests/0069-cdb.pl
* Missing features
** TODO once/1
** TODO setof/bagof
** TODO Extend numerical operators
   - constants "pi", perhaps "e"
   - "max", "min", "asin", "acos"
** TODO Allow iterating over all items in a DB
   - needed for listing/0 in pi.
** TODO Make it possible to embed compiled code
    - "suspend(IN, OUT)" saves state and suspends execution.
    - define alternative entry-point via macro and return procedure
      ptr to invoke prolog (similar to BONES).
    - also allow access to global_variables, and (prefixed) access
      function.
** TODO Add library predicates
*** TODO ord_membercheck/2
    - possibly as primitive.
* Diagnostics
** Detect singleton variables
** Detect redefinitions of primitives
** Detect undefined predicate calls
** Report unused predicates
** Detect non-contiguous predicates
* Once we have a suitable test, compare performance with other implementations
  - SWI, GNU-Prolog, BinProlog
* Issues
** Using multiple threads are currently not possible
   - all static vars would have to be declared TLS, but these may not
     be statically initialized with non-constants, and this applies to
     many data objects for literals.
** TODO Unbound var in arithmetic expr doesn't show variable name
   - extend var-rep to hold name, in addition to index.
** TODO Check fixnum range when emitting literals 
   - restrict to 32-bit to keep source-file portable.
** trail-GC
    - and adjust CP-stack entries accordingly.
    - tricky.
** Is cycle-checking in =deref= really necessary?
   - apparently it is (various tests loop if this is disabled)
** TODO reader-errors should go to stderr
** TODO May a PI (predicate-indicator) be an atom, refering to all available arities?
    - would need to be added to abolish/1.
** TODO Throw ISO-compliant exceptions everywhere
    - at least as much as possible and sensible.
** TODO file:broken-tests/simple_analyzer.pl gives wrong output
    - exhausts heap, regardless of size.
    - probably too much trailing or missed tailcall-opportunities.
** TODO ecrc benchmarks in file:/broken-tests work, but need higher settings
   - file:broken-tests/bench_1_3.pl needs -:C20M
   - file:broken-tests/bench_1_5.pl needs -:T5M
* Interpreter
** TODO Could add support for file:dcg.pl 
   - term_expansion? goal_expansion?
** TODO Additional predicates
   - listing/1
   - listing/0
     - needs some way to enumerate all predicates (current_predicate/1).
* Test suites
** file:/archive/prologsuite.tar.gz
** file:/archive/inriasuite.tar.gz
