NOTES											              -*- Org -*-


* Optimization opportunities
** Anonymous variables could get special handling when in argument position
   - unification is a noop, unless nested in another term.
** Mode-declarations
** Determinacy declarations
   - i.e. ":- determinate(PI)."
** Clause indexing
*** This could even be extended to invoke particular entry-points depending on call-arguments
** Arithmetic
   - deref all vars just once at start.
   - track types, use unboxed math.
** Last clause of predicate with a single call can be treated as determinate (and enable TCO)
   - if we know about determinacy of library predicates, this could be
     generalized to multiple calls.
** Deterministic goal in condition of if-then-else can drop CP dance
   - same for '\\+'/2
* Things to test
** TODO GC symbol-reclamation
** TODO file:io.pl
** TODO file:rdb.pl
** TODO file:code/crypta.pl
** TODO test file:rdtok.pl, file:read.pl (self-compiled)
   - use of file:op.pl.
** TODO file:write.pl
   - including file:op.pl
** TODO tests for new macros and autoloads
   - erase
** TODO tests for stuff in file:code/
   - ordsets, queues, writef, write
** TODO Test on Mac, Windows (32 bit) and R/Pi
* Missing features
** Compiler
*** TODO Add macros for everything in file:prelude.pl
    - include library files in boilerplate, as necessary.
    - remove that file afterwards.
*** TODO current_op/3 and op-database
    - need some internal DB
*** Add support for DCGs
    - probably using file:code/dcg.pl
*** TODO add auto-includes to file:macros.pl
    - file:misc.pl, file:op.pl, file:io.pl, file:rdb.pl
*** Allow selective tracing
    - declaration "trace(PI)", where PI may be atom, NAME/ARITY, or
      list of those.
** Library/Runtime
*** TODO findall/3
    - macro + library (file:findall.pl)
*** TODO clause-DB
    - file:cdb.pl
*** TODO autoincludes for file:io.pl and file:op.pl
*** Make it possible to embed compiled code
    - "suspend(IN, OUT)" saves state and suspends execution.
    - define alternative entry-point via macro and return procedure
      ptr to invoke prolog (similar to BONES).
*** Runtime-information about defined clauses
    - as minimum: mapping of name/arity -> entry-point.
    - for complete support of clause/2 we would actually need the full
      source.
    - at least compiler could offer "call_predicate".
*** TODO Primitives needed
    | atom_codes(ATOM, LIST)              |
    | number_codes(NUMBER, LIST)          | 
*** TODO Non-standard predicates we need for bootstrapping
    | atomic_list_concat/2 | add to file:misc.pl |
    | union/3              | file:sets.pl        |
* Diagnostics
** Detect singleton variables
** Detect redefinitions of primitives
** Detect non-contiguous predicates
* TODO Once we have a suitable test, compare performance with other implementations
  - maybe file:queens.pl
  - SWI, GNU-Prolog, BinProlog
* Issues
** Compiler
*** TODO Command-line option to set include-path
    - "-I PATH"
*** TODO Improve and extend directives
    - determinate :: register as determinate, use this to find more
                    TCO opportunities and reduce temporary CPs in
                    if-then-else, not, etc.
*** TODO Unbound var in arithmetic expr doesn't show variable name
   - extend var-rep to hold name, in addition to index.
*** TODO check fixnum range when emitting literals 
** Runtime
*** TODO Reconsider default data-area sizes
*** TODO trail-GC
    - and adjust CP-stack entries accordingly.
    - tricky.
*** TODO Should "make_term" deref it's args, especially the functor?
*** TODO Is cycle-checking in =deref= really necessary?
* List of available primitives
  | basic_write(X)                      |
  | basic_writeq(X)                     |
  | close_stream(S)                     |
  | command_line_arguments(X)           |
  | current_error_stream(STREAM)        |
  | current_input_stream(STREAM)        |
  | current_output_stream(STREAM)       |
  | db_create(NAME, SIZE, DB)           |
  | db_erase(REF)                       |
  | db_find(DB, KEY, REF)               |
  | db_next(REF, REF2)                  |
  | db_record(DB, ATEND, KEY, VAL, REF) |
  | db_ref(REF, VAL)                    |
  | debug_hook(X)                       |
  | gc                                  |
  | get_byte(BYTE)                      |
  | get_environment_variable(NAME, VAL) |
  | halt(I)                             |
  | open_stream(NAME, INPUT?, STREAM)   |
  | peek_byte(BYTE)                     |
  | put_byte(CHAR)                      |
  | put_string(STREAM, ATOM/LIST)       |
  | set_current_error_stream(STREAM)    |
  | set_current_input_stream(STREAM)    |
  | set_current_output_stream(STREAM)   |
  | shell_command(CMD, STATUS)          |
  | write_char(I)                       |
* List of builtin and library predicates
  | Name                         | Type | Library  | Notes                                                                |
  |------------------------------+------+----------+----------------------------------------------------------------------|
  | append(L1, L2, L3)           | A    | lists.pl |                                                                      |
  | atom(X)                      | P    |          |                                                                      |
  | atomic(X)                    | P    |          |                                                                      |
  | command_line_arguments(LIST) | M    |          | Filters out runtime-options ("-:..."), does not include program name |
  | compare(REL, X, Y)           | A    | misc.pl  |                                                                      |
  | compound(X)                  | P    |          |                                                                      |
  | display(X)                   | M    |          |                                                                      |
  | erase(REF)                   | M    |          |                                                                      |
  | exists_file(NAME)            | M    |          | fails if nonexistent or not a regular file                           |
  | float(X)                     | P    |          |                                                                      |
  | foreign_call(TERM)           | P    |          |                                                                      |
  | garbage_collect              | M    |          |                                                                      |
  | get(C)                       | A    | io.pl    | -1 on EOF                                                            |
  | get0(C)                      | M    |          | -1 on EOF                                                            |
  | get_global(ATOM, X)          | P    |          |                                                                      |
  | getenv(NAME, VALUE)          | M    |          | fails if variable doesn't exist                                      |
  | halt                         | M    |          | exits with code 0                                                    |
  | halt(CODE)                   | M    |          |                                                                      |
  | integer(X)                   | P    |          |                                                                      |
  | length(LIST, NUM)            | A    | lists.pl |                                                                      |
  | member(X, LST)               | A    | lists.pl |                                                                      |
  | nl                           | M    |          |                                                                      |
  | nonvar(X)                    | P    |          |                                                                      |
  | number(X)                    | P    |          |                                                                      |
  | peek(BYTE)                   | M    |          | -1 on EOF                                                            |
  | put(CHAR)                    | M    |          | CHAR may be fixnum or symbol                                         |
  | reverse(LST1, LST2)          | A    | lists.pl |                                                                      |
  | see(FILE)                    | A    | io.pl    | may also pass stream                                                 |
  | seeing(FILE)                 | A    | io.pl    |                                                                      |
  | seen                         | A    | io.pl    | does nothing if stdin                                                |
  | select(ELEM, LIST1, LIST2)   | A    | lists.pl |                                                                      |
  | set_global(ATOM, X)          | P    |          |                                                                      |
  | shell(COMMAND)               | A    | misc.pl  | expects exit-status 0                                                |
  | shell(COMMAND, STATUS)       | M    |          |                                                                      |
  | skip(C)                      | A    | io.pl    |                                                                      |
  | stream(X)                    | P    |          |                                                                      |
  | tab(C)                       | A    | io.pl    |                                                                      |
  | tell(FILE)                   | A    | io.pl    | may also pass stream                                                 |
  | telling(STREAM)              | A    | io.pl    |                                                                      |
  | told                         | A    | io.pl    | does nothing if stdout or stderr                                     |
  | var(X)                       | P    |          |                                                                      |
  - "M" = macro, "A" = autoload, "P" = primitive (in compiler)
* Test suites
** file:/archive/prologsuite.tar.gz
** file:/archive/inriasuite.tar.gz
* Benchmark suites
** http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/prolog/code/bench/
