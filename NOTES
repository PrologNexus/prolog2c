NOTES											              -*- Org -*-


* Wrapper generator
** Find a good example
** Add support for structs
   - struct X* <-> "X(...)"
* Optimization opportunities
** TODO Dispatch also on structure terms
   - modify hash by arity, store name + arity + label in table.
** Environment trimming
   - sort variables by lifetime (reversed) and trim env_top after last use.
   - may only be applicable when env_top didn't change.
** TODO Avoid allocating intermediate results if they are unified with ground values
   - when unifying recursively, check result for being identical.
** TODO Add "determinate" declarations and green cuts in library code
** Use perfect hashing for atom-tables
   - http://www.burtleburtle.net/bob/hash/perfect.html
** Special-case primitives that are known to always succeed?
** DONE Take advantage of timestamps when binding vars in unify()
   - implemented in branch /bind-younger/ and seems to work, but trail
** writeq/1 could use foreign_call(basic_writeq(X)) for atoms
   - but the name needs to be classified anyway, because of the possibly
     required space in front of it.
** Mode-declarations
   - can probably be used in many ways, but needs more thought.
** Arithmetic
   - deref all vars just once at start.
   - track types, use unboxed math.
** With some sort of type/groundness analysis many primitives can be rewritten to simpler forms
   - functor, arg, name, univ, etc.
   - atom_codes/2 could fail on full heap, force GC and retry,
     would need to be moved into file:lib/misc.pl
** current_op/3 needs fast path when operator name is known
   - could use single-bucket db, with unififcation inside
     db_find/db_next (provided, we implement matching in file:pc.h)
** Deterministic goal in condition of if-then-else can drop some of the CP dance
   - same for '\\+'/2
   - fail could actually just perform a jump, perhaps redefine FAIL
     temporarily (or use intermediate macro).
** Analyze program before compiling to pseudo-instructions
   - perform determinacy-analysis for all code.
   - in other words: actually take advantage of having a static whole-program compiler.
* Features
** TODO Version pc, pi, pb
   - "-version" option.
   - file:version.pl, included everywhere.
   - prolog_version(V) :: unify V with version number.
** Allow access to delay goals
   - frozen(VAR, PTRARGS) :: return ptr/args pairs,
        non-deterministically
   - document '$call_predicate' + '$predicate_address'
** Some sort of configuration-language (similar to SRFI-7)
   - basically needs sth like "cond-expand".
   - expands into compilable source code.
** Unicode
   - arbitrary character codes in strings (UTF-8?)
   - atom-length (string_length())
   - extend name/2, get/1, get0/1, put/1, skip/1 (and probably many
     more)
** once/1
** Allow "library(ATOM)" as file-spec
   - consult/1, include/1
** freeze/2
   - see /coroutines/ branch, still not right (indirect variable binding)
   - benchmark.
** Allow user-defined macros
   - directive: ":- macro OLD -> NEW" or something like this.
** Extend numerical operators
   - constants "pi", perhaps "e"
   - "max", "min", "asin", "acos"
** Add low-level predicates
   - predicate_address(PRED, PTR) :: unify PTR with label address
   - call_predicate(PTR, ARGS) :: call predicate at address, also
        provide in interp.pl
* Documentation
** TODO Add version number and history.
* Build options
** Allow static allocation of data-areas
   - statically allocated data for all areas.
   - fixed sizes for gap-buffer and string-buffer.
   - would need to put DBs, buckets and items into heap, using bytevectors.
** Allow keeping db-data in GC'd heap
   - freeze/thaw would be just a deep copy.
   - needs to check heap and possibly GC before asserting/recording.
** Make use of floating-point optional
   - see /intmath/ branch.
   - had funny behaviour with pi (use of flonum simple aborts.)
* Bare-metal
** Keep DB in heap
   - Implement completely in Prolog, using different lib.
** Absolutely positioned data areas
** Reimplement as much as possible in Prolog
** Asm core
*** Basic I/O
    - debugging output (serial line)
    - console (to/from framebuffer)
*** FP operation and transcendental functions
    - probably needs to init FPU properly.
** Reimplement string and ctype operations
** Reimplement random numbers
** No file system
** More tricky
   - clock
   - longjmp/setjmp, but should be doable with simple
     register-save/restore.
** We need flonum<->string conversion
   - http://krashan.ppa.pl/articles/stringtofloat/
** Currently imported symbols:
   | Name             | Class |
   |------------------+-------|
   | __ctype_b_loc    | R     |
   | __errno_location | D     |
   | _setjmp          | A     |
   | atan             | O     |
   | atol             | R/O   |
   | ceil             | R/O   |
   | clock_gettime    | D     |
   | close            | D     |
   | cos              | O     |
   | exit             | D     |
   | exp              | O     |
   | fclose           | D     |
   | fflush           | D     |
   | fgetc            | R/A   |
   | floor            | R/O   |
   | fopen            | D     |
   | fprintf          |       |
   | fputc            | R/A   |
   | fputs            |       |
   | free             | -     |
   | ftruncate        |       |
   | fwrite           | R/A   |
   | getenv           | D     |
   | getpid           | D     |
   | log              | O     |
   | longjmp          | A     |
   | malloc           | -     |
   | memcmp           | R     |
   | memcpy           | R     |
   | memset           | R     |
   | mmap             | D     |
   | modf             | O     |
   | munmap           | D     |
   | open             |       |
   | pow              |       |
   | rand             | D     |
   | realloc          | -     |
   | round            | R/O   |
   | sin              | O     |
   | sleep            | D     |
   | sprintf          |       |
   | sqrt             | O     |
   | srand            | D     |
   | stat             | D     |
   | stderr           | R/A   |
   | stdin            | R/A   |
   | stdout           | R/A   |
   | strerror         | D     |
   | strncmp          | R     |
   | strtod           |       |
   | strtol           |       |
   | system           | D     |
   | toupper          | R     |
   | trunc            | R/O   |
   | ungetc           | R     |
   Class: R = reimplement, D = drop, O = optional, A = asm impl.
* Diagnostics
** Detect singleton variables
** Report unused predicates
* Tests
** TODO test freezing/thawing of delayed vars
** TODO Find some non-trivial test for coroutines
** TODO Test once more on WIN64
** TODO Does retract-loop work?
   - we know it works for the rdb, but should also test for cdb.
* Issues
** Major
*** TODO delay/2: binding of var that is bound to frozen var will not trigger the goal
    - could we copy the frozen-goal list of one var to the other?
      - would have to be undone when detrailing.
*** TODO [#B] Implementation of if-then-else seems to be broken
   - if-then stack gets out of balance, found here:
     call_primitive('->', 2, TERM) :-
	!,
	arg(1, TERM, X), arg(2, TERM, Y),
	execute(X) -> execute(Y). % parsed as (!, ...) -> execute(Y)
   - adding parens around last goal repaired the problem, but still
     this shouldn't happen.
*** 32-bit version can't tokenize fractional part of real if it doesn't fit into an integer
   - e.g.:
     main :- f(0.463647609000806).
*** Everything is still rather slow and uses too much memory
   - see file:broken-tests/
*** Once trail-stack reserve is reached, GC will happen all the time if the trail can't be reduced
*** If heap is insufficient deref_term/3 will loop endlessly
   - also read_atom/2, recorded/X, retract/1 and clause/X
*** name/2 and functor/3 (and others?) may exceed heap-reserve for large inputs
*** TODO 0085-boyer crashes in pi sometimes
** Minor
*** Undefined clauses in interp fail instead of throwing error
    - error would be better, but combined clause-retrieval and
      unification with goal means that we would have to check after
      failure whether the predicate is defined at all.
*** Failure in term_expansion/2 will simply be ignored
*** The output of TRACE_TAILCALL() is somewhat confusing
    - Not sure if arguments output reflects the correct state.
    - can we get rid of this?
*** Reduce memory use in pc
    - seems to build up a lot of choice points.
*** Erasing a db-entry that is already marked is currently ignored
   - actual deletion will happen on next GC.
   - should we throw an error?
   - note that 0069-cdb deletes twice: first the retract of hello(X)
     and then the abolish of hello/1.
*** Handle freezing of db-refs
   - delete from deleted-items list?
   - what can happen?
   - currently caught by assertion in freeze_term_recursive()
*** Using multiple threads is currently not possible
   - all static vars would have to be declared TLS, but these may not
     be statically initialized with non-constants, and this applies to
     many data objects for literals.
   - but user-defined literals can't be shared, or not?
*** Unbound var in arithmetic expr doesn't show variable name
   - extend var-rep to hold name, in addition to index.
*** Reader-error should throw syntax_error with message argument
*** Throw ISO-compliant exceptions everywhere
    - at least as much as possible and sensible.
*** Isn't most of the stuff in file:lib/ordset.pl, file:lib/sets.pl determinate?
* Interpreter
** Add "ensure_loaded" directive
** Add "listing"
   - listing/1
   - listing/0
     - needs some way to enumerate all predicates (current_predicate/1).
     - could use foreign_call(db_find_bucket(...))
* Test suites
** file:/archive/prologsuite.tar.gz
** file:/archive/inriasuite.tar.gz
** file:/archive/iclpgcbenches.tar.gz
* Undocumented features
** '$predicate_address'/2, '$call_predicate'/2
** interp: expand_term/2 + term_expansion/2
