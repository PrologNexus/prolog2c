NOTES											              -*- Org -*-


* Optimization opportunities
** Anonymous variables could get special handling when in argument position
   - unification is a noop, unless nested in another term.
** Mode-declarations
** Determinacy declarations
   - i.e. ":- determinate(PI)."
** Clause indexing
*** This could even be extended to invoke particular entry-points depending on call-arguments
** Arithmetic
   - deref all vars just once at start.
   - track types, use unboxed math.
** Last clause of predicate with a single call can be treated as determinate (and enable TCO)
   - if we know about determinacy of library predicates, this could be
     generalized to multiple calls.
** Deterministic goal in condition of if-then-else can drop CP dance
   - same for '\\+'/2
* Things to test
** TODO GC symbol-reclamation.
** TODO all numerical functions + operators
** TODO file:code/crypta.pl
** TODO test file:rdtok.pl, file:read.pl (self-compiled)
** TODO tests for stuff in file:code/
   - ordsets, queues, writef, write
* Missing features
** Compiler
*** TODO Add macros for everything in file:prelude.pl
    - include library files in boilerplate, as necessary.
    - remove that file afterwards.
*** Write driver script
    - handles compilation to C.
    - could run separate program to preprocess source.
    - could even filter out latent term_expansions expressions and build
      preprocessor on the fly.
*** Allow selective tracing
    - declaration "trace(PI)", where PI may be atom, NAME/ARITY, or
      list of those.
** Library/Runtime
*** Runtime-information about defined clauses
    - as minimum: mapping of name/arity -> entry-point.
    - for complete support of clause/2 we would actually need the full
      source.
    - at least compiler could offer "call_predicate".
*** Basic Edinburgh I/O
    - "see", "seen", "seeing", "tell", "told", "telling"
    - stream-alias "user" (default I/O ports)
    - "get", "get0", "put", "peek"
*** TODO Primitives needed
    | file_exists(NAME)                   |
    | open_stream(FILENAME, I/O?, STREAM) |
    | close_sream(STREAM)                 |
    | get_byte(BYTE)                      |
    | put_byte(BYTE)                      |
    | put_string(STREAM, ATOM/LIST)       |
    | shell_command(STRING, EXITCODE)     |
    | eof(STREAM)                         |
    | current_input(STREAM)               |
    | current_output(STREAM)              |
    | current_error_output(STREAM)        |
*** TODO Non-standard predicates we need for bootstrapping
    | getenv/1                 |                                                                     |
    | command_line_arguments/1 |                                                                     |
    | file_exists/1            | needed for more convenient include/1 and ensure_loaded/1 directives |
    | atomic_list_concat/2     |                                                                     |
    | union/3                  |                                                                     |
* Diagnostics
** Detect singleton variables
** Detect redefinitions of primitives
** Detect non-contiguous predicates
* TODO Once we have a suitable test, compare performance with other implementations
  - maybe file:queens.pl
  - SWI, GNU-Prolog, BinProlog
* Issues
** Compiler
*** TODO Command-line option to set include-path
    - "-I PATH"
*** TODO Improve and extend directives
    - ensure_loaded :: like "include", but include only once.
    - determinate :: register as determinate, use this to find more
                    TCO opportunities and reduce temporary CPs in
                    if-then-else, not, etc.
*** TODO Unbound var in arithmetic expr doesn't show variable name
   - extend var-rep to hold name, in addition to index.
*** TODO check fixnum range when emitting literals 
** Runtime
*** TODO Reconsider default data-area sizes
*** TODO trail-GC
    - and adjust CP-stack entries accordingly.
    - tricky.
*** TODO Should "make_term" deref it's args, especially the functor?
*** TODO Is cycle-checking in =deref= really necessary?
* List of primitives, callable via =foreign_call=
  | basic_write(X)                      | only handles symbol, number, [], var, port, doesn*t quotes                            |
  | basic_writeq(X)                     | quotes atoms                                                                          |
  | command_line_arguments(X)           | filters runtime options out                                                           |
  | db_create(NAME, SIZE, DB)           | create database, with given name (atom), table-size and unifies DB with db-designator |
  | db_erase(REF)                       | erases DB entry, invalidating all other refs to this item                             |
  | db_find(DB, KEY, REF)               | unifies REF with first entry found for KEY (atom)                                     |
  | db_next(REF, REF2)                  | unifies REF2 with entry after REF or fails                                            |
  | db_record(DB, ATEND, KEY, VAL, REF) | inserts new item (ATEND != 0: insert at end)                                          |
  | db_ref(REF, VAL)                    | unifies VAL with referenced item or fails if GC is needed (so VAL should be a var)    |
  | debug_hook(X)                       | does nothing, suitable for hooking into                                               |
  | gc                                  | perform garbage collection                                                            |
  | halt(I)                             | terminate process                                                                     |
  | write_char(I)                       | write to current output stream                                                        |
* List of builtin macros
  | display(X)      |   |
  | garbage_collect |   |
  | nl              |   |
* Test suites
** file:/archive/prologsuite.tar.gz
** file:/archive/inriasuite.tar.gz
* Benchmark suites
** http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/prolog/code/bench/
