NOTES											              -*- Org -*-


* Issues
** Major
*** TODO Why is so much space accumulating on arg- and env-stacks?
*** TODO 0028-endless-tailcall crashes in pi
    - hits some limit, not sure which.
    - is in any case not keeping the memory-use constant.
*** TODO [#B] Implementation of if-then-else seems to be broken
   - if-then stack gets out of balance, found here:
     call_primitive('->', 2, TERM) :-
	!,
	arg(1, TERM, X), arg(2, TERM, Y),
	execute(X) -> execute(Y). % parsed as (!, ...) -> execute(Y)
   - adding parens around last goal repaired the problem, but still
     this shouldn't happen.
*** 0007-pi benchmark needs high memory/trail settings
    - crashes with defaults, which is to be expected, but it would be
      nice to catch this properly.
*** 32-bit version can't tokenize fractional part of real if it doesn't fit into an integer
   - e.g.:
     main :- f(0.463647609000806).
*** Everything is still rather slow and uses too much memory
   - see file:broken-tests/
*** Once trail-stack reserve is reached, GC will happen all the time if the trail can't be reduced
*** If heap is insufficient deref_term/3 will loop endlessly
   - also read_atom/2, recorded/X, retract/1 and clause/X
*** name/2 and functor/3 (and others?) may exceed heap-reserve for large inputs
   - atom_codes/2 could fail on full heap, force GC and retry,
     would need to be moved into file:lib/misc.pl
** Minor
*** TODO Fresh checkout often leaves file:g-s-p.pl uncompiled
    - only rebuilds g-s-p.c, but that might not be sufficient.
*** pb should understand "volatile"
*** Failure in term_expansion/2 will simply be ignored
*** The output of TRACE_TAILCALL() is somewhat confusing
    - Not sure if arguments output reflects the correct state.
    - can we get rid of this?
*** Reduce memory use in pc
    - seems to build up a lot of choice points.
*** Erasing a db-entry that is already marked is currently ignored
   - actual deletion will happen on next GC.
   - should we throw an error?
   - note that 0069-cdb deletes twice: first the retract of hello(X)
     and then the abolish of hello/1.
*** Handle freezing of db-refs
   - delete from deleted-items list?
   - what can happen?
   - currently caught by assertion in freeze_term_recursive()
*** Using multiple threads is currently not possible
   - all static vars would have to be declared TLS, but these may not
     be statically initialized with non-constants, and this applies to
     many data objects for literals.
   - but user-defined literals can't be shared, or not?
*** Unbound var in arithmetic expr doesn't show variable name
   - extend var-rep to hold name, in addition to index.
*** Reader-error should throw syntax_error with message argument
*** Throw ISO-compliant exceptions everywhere
    - at least as much as possible and sensible.
*** Isn't most of the stuff in file:lib/ordset.pl, file:lib/sets.pl determinate?
* Optimization opportunities
** If clause contains a single tail-call, CP-creation could be avoided
   - saves little, though.
** Remove unused predicates
   - could be done in assembly-stage
     - register called predicates (and caller), compute unused
       predicates and predicates used by other unused predicates and
       drop sections of pseudo-instructions.
     - add pseudo-instructions for marking start + end of predicate
       definition.
** Peephole optimization of pseudo-instructions
** Environment trimming
   - sort variables by lifetime (reversed) and trim env_top after last use.
   - may only be applicable when env_top didn't change.
** Add "determinate" declarations and green cuts in library code
   - profile to find suitable points of improvement.
** Special-case calls of primitives that are known to always succeed
** DONE Take advantage of timestamps when binding vars in unify()
   - implemented in branch /bind-younger/ and seems to work, but trail
     is not slightly smaller.
** writeq/1 could use foreign_call(basic_writeq(X)) for atoms
   - but the name needs to be classified anyway, because of the possibly
     required space in front of it.
** Arithmetic
   - deref all vars just once at start.
   - track types, use unboxed math.
** 2-stream unification
   - rather complicated, first attempt at implementation ended in
     quite a mess and was abandoned.
** With some sort of type/groundness analysis many primitives could be optimized
   - functor, arg, name, univ, etc.
   - rewrite to simpler forms.
** current_op/3 needs fast path when operator name is known
   - could use single-bucket db, with unififcation inside
     db_find/db_next (provided, we implement matching in file:pc.h)
** Deterministic goal in condition of if-then-else can drop some of the CP dance
   - same for '\\+'/2, once/1
   - fail could actually just perform a jump, perhaps redefine FAIL
     temporarily (or use intermediate macro).
** Analyze program before compiling to pseudo-instructions
   - perform determinacy-analysis for all code.
   - in other words: actually take advantage of having a static whole-program compiler.
* Features
** TODO if term_expansion/2 returns list, treat as separate (or no) terms
** TODO current_prolog_flag/2, set_prolog_flag/2
   | Name                      | Default   | Changable |
   |---------------------------+-----------+-----------|
   | bounded                   | false     | -         |
   | max_arity                 | ?         | -         |
   | integer_rounding_function | ?         | -         |
   | max_integer               | ?         | -         |
   | min_integer               | ?         | -         |
   | unknown                   | error     | -         |
   | version                   | <VERSION> | -         | 
   - put into lib/misc, includes lib/version (replaces current
     file:version.pl)
** TODO Add support for ensure_loaded/1 in compiler  
** Predicates
   - simple atom-concatenation, at least as determinate primitive.
** Show warning for untriggered delayed goals with "-:d"
   - check trail-entries when unwinding trail and before exit.
** Allow access to delay goals
   - frozen(VAR, PTRARGS) :: return ptr/args pairs,
        non-deterministically
** Unicode
   - arbitrary character codes in strings (UTF-8?)
   - atom-length (string_length())
   - extend name/2, get/1, get0/1, put/1, skip/1 (and probably many
     more)
** Allow "library(ATOM)" as file-spec
   - consult/1, include/1, ensure_loaded/1
   - would this simply prepend "lib/"?
** Extend numerical operators
   - constants "pi", perhaps "e"
   - "max", "min", "asin", "acos"
* Documentation
** DONE News
   - more lightweight copy_term/2, added duplicate_term/2
   - read_line/1
   - profiling.
   - string-canonicalization didn't handle empty strings.
   - pb: "-i" option.
   - pb: handling "\" inside text (not followed by WS + NL)
   - pb: fixed handling zero-argument function with result.
   - pb: "/* success */" result modifier.
   - once/1
   - undefined goals in interpreter throw error.
   - slightly faster db-key computation.
   - pi: ensure_loaded/1 directive.
   - added -q option to pi, also added some verbose output when including/consulting.
* Build options
** Allow static allocation of data-areas
   - statically allocated data for all areas.
   - fixed sizes for gap-buffer and string-buffer.
   - would need to put DBs, buckets and items into heap, using bytevectors.
* Diagnostics
** Detect singleton variables
** Report unused predicates
* Experimental
** DONE /memprofile/ (memory-profiling)
   - not sure if this is truly correct or useful.
** DONE /pi-in-pc/ (make interpreter available in compiler)
   - use of term_expansion/2 is awkward, but handy.
   - allows arbitrary latent goals.
   - compare file-size + compile overhead in optimized mode.
   - would allow conditional compilation.
** prolog-implementation of CDB
   - needs tree-based DB, perhaps using lib/tree23.
   - problematic, as it depends on GC'd trailed vars and needs 2 tree
     lookups for recording (to add a new element to an existing list of
     old vals: first to get old, second to put old with new added)
     - update_23 allows this, by adding a variable and unifying it
       with the result-"mode".
   - term-copying needed for storing new DB in global copies whole
     DB, which is too inefficient.
     - might be addressed by more efficient deref_all()
   - dbreference type changes.
** DONE /intmath/ (integer-only math)
   - lib/rdtok returns end_of_file when reading flonum (which makes pi
     terminate, for example)
   - would have to disable flonum-parsing in rdtok, which needs
     conditional, depending on variant (with flonums or without)
* Runtime
** TODO Use macro to check for exceeded heap-limit
* Tests
** TODO profile with gprof
* Interpreter
** TODO Allow detecting interpreter from running program
   - or find some trick.
   - could simply record some entry in RDB.
** Add "listing"
   - listing/1
   - listing/0
     - needs some way to enumerate all predicates (current_predicate/1).
     - could use foreign_call(db_find_bucket(...))
* Test suites
** file:/archive/prologsuite.tar.gz
** file:/archive/inriasuite.tar.gz
** file:/archive/iclpgcbenches.tar.gz
* Undocumented features
** Compiler
*** '$predicate_address'/2
** Builtins
*** '$call_predicate'/2
** Interpreter
*** expand_term/2 + term_expansion/2
* Release steps
** Document changes
** make fullcheck
** Test on WIN64
** Test on Mac
** Test on [pi], [call-cc]
** Test dist
** Tag, push, upload
** Bump version (file:README + file:version.pl)
