NOTES											              -*- Org -*-


* Optimization opportunities
** Singleton variables could get special handling when in argument position
   - unification is a noop, unless nested in another term.
** TODO Implement memberchk/2 as primitive
** Mode-declarations
** TODO Determinacy declarations
   - i.e. ":- determinate(PI)."
   - file:da.pl
   - provide predicate "is_deterministic(EXPR)"
   - add declarations for all library predicates, where appropriate.
** Clause indexing
*** This could even be extended to invoke particular entry-points depending on call-arguments
** Arithmetic
   - deref all vars just once at start.
   - track types, use unboxed math.
** With some sort of type/groundness analysis many primitives can be rewritten to simpler forms
   - functor, arg, name, '=..', etc.
** Matching term in db could be done in C
*** Unify inside db_find/db_next (properly undwinding trail on failure)
    - handling heap-full case on thawing still makes this ugly.
** TODO current_op/3 needs fast path when operator name is known
   - could use single-bucket db, with unififcation inside
     db_find/db_next (provided, we implement matching in pc.h)
** Deterministic goal in condition of if-then-else can drop some of the CP dance
   - same for '\\+'/2
   - fail could actually just perform a jump.
** Analyze program before compiling to pseudo-instructions
   - perform determinacy-analysis for all code.
   - in other words: actually take advantage of having a static whole-program compiler.
* TODO Find proper name
* TODO Move repo to bitbucket
* Benchmark results
** Self-compile, 5 times, average of medium 3 runtimes
   - <2015-01-04 Sun>: 2.38s
* Things to test
** TODO Test on Mac, Windows and R/Pi
** TODO Test in 32-bit mode
** TODO test retract-loop
   - file:tests/0069-cdb.pl
* Missing features
** Library/Runtime
*** Make it possible to embed compiled code
    - "suspend(IN, OUT)" saves state and suspends execution.
    - define alternative entry-point via macro and return procedure
      ptr to invoke prolog (similar to BONES).
    - also allow access to global_variables, and (prefixed) access
      function.
*** Runtime-information about defined clauses
    - as minimum: mapping of name/arity -> entry-point.
    - for complete support of clause/2 we would actually need the full
      source.
    - at least compiler could offer "call_predicate".
* Diagnostics
** Detect singleton variables
** Detect redefinitions of primitives
** Detect undefined predicate calls
** Detect non-contiguous predicates
* TODO Once we have a suitable test, compare performance with other implementations
  - maybe file:queens.pl
  - SWI, GNU-Prolog, BinProlog
* Issues
** TODO Memory consumption is too high
   - self-compile with pc1 needs loads of memory
   - parameters: "pc1 pc.pl -o pc2.c -:h500M -:C100M -:E100M -:A100M"
** Compiler
*** TODO Unbound var in arithmetic expr doesn't show variable name
   - extend var-rep to hold name, in addition to index.
*** TODO check fixnum range when emitting literals 
** Runtime
*** TODO trail-GC
    - and adjust CP-stack entries accordingly.
    - tricky.
*** TODO Is cycle-checking in =deref= really necessary?
** Libraries
*** TODO May a PI (predicate-indicator) be an atom, refering to all available arities?
    - would need to be added to abolish/1.
*** TODO op/3 should throw ISO-compliant exceptions
* List of builtin and library predicates
** TODO Use "descriptors" for arguments in this list
   - "+" :: must be instantiated
   - "-" :: must be unbound
   - "?" :: must be partially instantiated
   - "@" :: argument is not instantiated (e.g. for type tests)
  | Name                         | Type | Library   | Notes                                                                |
  |------------------------------+------+-----------+----------------------------------------------------------------------|
  | X, Y                         | S    |           |                                                                      |
  | X; Y                         | S    |           |                                                                      |
  | X = Y                        | S    |           |                                                                      |
  | X -> Y                       | S    |           |                                                                      |
  | X -> Y; Z                    | S    |           |                                                                      |
  | '!'                          | S    |           |                                                                      |
  | \+ X                         | S    |           |                                                                      |
  | X \= Y                       | S    |           |                                                                      |
  | X == Y                       | S    |           |                                                                      |
  | X \== Y                      | S    |           |                                                                      |
  | EXP1 < EXP1                  | S    |           |                                                                      |
  | EXP1 > EXP2                  | S    |           |                                                                      |
  | EXP1 =< EXP2                 | S    |           |                                                                      |
  | EXP1 >= EXP2                 | S    |           |                                                                      |
  | EXP1 =:= EXP2                | S    |           |                                                                      |
  | EXP1 =\= EXP2                | S    |           |                                                                      |
  | X @< Y                       | S    |           |                                                                      |
  | X @> Y                       | S    |           |                                                                      |
  | X @=< Y                      | S    |           |                                                                      |
  | X @>= Y                      | S    |           |                                                                      |
  | abolish(PI)                  | A    | cdb.pl    |                                                                      |
  | append(L1, L2, L3)           | A    | lists.pl  |                                                                      |
  | arg(INDEX, TERM, X)          | M    |           |                                                                      |
  | asserta(CLAUSE)              | A    | cdb.pl    |                                                                      |
  | asserta(CLAUSE, REF)         | A    | cdb.pl    |                                                                      |
  | assertz(CLAUSE)              | A    | cdb.pl    |                                                                      |
  | assertz(CLAUSE, REF)         | A    | cdb.pl    |                                                                      |
  | atom(X)                      | P    |           |                                                                      |
  | atom_codes(ATOM, LIST)       | M    |           |                                                                      |
  | atomic(X)                    | P    |           |                                                                      |
  | clause(HEAD, BODY)           | A    | cdb.pl    |                                                                      |
  | clause(HEAD, BODY, REF)      | A    | cdb.pl    |                                                                      |
  | command_line_arguments(LIST) | M    |           | Filters out runtime-options ("-:..."), does not include program name |
  | compare(REL, X, Y)           | A    | misc.pl   |                                                                      |
  | compound(X)                  | P    |           |                                                                      |
  | copy_term(X, Y)              | A    | misc.pl   |                                                                      |
  | current_input(S)             | M    |           |                                                                      |
  | current_output(S)            | M    |           |                                                                      |
  | current_op(P, A, N)          | A    | op.pl     |                                                                      |
  | db_reference(X)              | M    |           |                                                                      |
  | display(X)                   | M    |           |                                                                      |
  | enable_trace(F)              | M    |           |                                                                      |
  | erase(REF)                   | M    |           |                                                                      |
  | exists_file(NAME)            | M    |           | fails if nonexistent or not a regular file                           |
  | fail                         | S    |           |                                                                      |
  | findall(T, G, L)             | S    |           | G must be a callable term, uses library "findall.pl"                 |
  | float(X)                     | P    |           |                                                                      |
  | forall(G, A)                 | S    |           |                                                                      |
  | foreign_call(TERM)           | S    |           |                                                                      |
  | garbage_collect              | M    |           | GC is triggered on next allocation                                   |
  | get(C)                       | A    | io.pl     | -1 on EOF                                                            |
  | get0(C)                      | M    |           | -1 on EOF                                                            |
  | get_global(ATOM, X)          | S    |           |                                                                      |
  | getenv(NAME, VALUE)          | M    |           | fails if variable doesn't exist                                      |
  | getpid(PID)                  | M    |           |                                                                      |
  | halt                         | M    |           | exits with code 0                                                    |
  | halt(CODE)                   | M    |           |                                                                      |
  | integer(X)                   | P    |           |                                                                      |
  | intersection(X, Y, Z)        | A    | sets.pl   |                                                                      |
  | X is EXP                     | S    |           |                                                                      |
  | keysort(S, R)                | A    | sorts.pl  |                                                                      |
  | length(LIST, NUM)            | A    | lists.pl  |                                                                      |
  | list_to_ord_set(L, S)        | A    | ordset.pl |                                                                      |
  | member(X, LST)               | A    | lists.pl  |                                                                      |
  | memberchk(X, LST)            | A    | lists.pl  |                                                                      |
  | merge(S1, S2, R)             | A    | sorts.pl  |                                                                      |
  | name(X, LST)                 | A    | misc.pl   |                                                                      |
  | nl                           | M    |           |                                                                      |
  | nonvar(X)                    | P    |           |                                                                      |
  | number(X)                    | P    |           |                                                                      |
  | number_codes(NUM, LIST)      | M    |           | uses strtol(3)/strtod(3), so allows leading space                    |
  | op(P, A, N)                  | A    | op.pl     |                                                                      |
  | ord_disjoint(S1, S2)         | A    | ordset.pl |                                                                      |
  | ord_insert(S1, ELT, S2)      | A    | ordset.pl |                                                                      |
  | ord_intersect(S1, S2)        | A    | ordset.pl |                                                                      |
  | ord_intersect(S1, S2, IS)    | A    | ordset.pl |                                                                      |
  | ord_seteq(S1, S2)            | A    | ordset.pl |                                                                      |
  | ord_subset(S1, S2)           | A    | ordset.pl |                                                                      |
  | ord_subtract(S1, S2, DS)     | A    | ordset.pl |                                                                      |
  | ord_symdiff(S1, S2, DS)      | A    | ordset.pl |                                                                      |
  | ord_union(S1, S2)            | A    | ordset.pl |                                                                      |
  | peek(BYTE)                   | M    |           | -1 on EOF                                                            |
  | put(CHAR)                    | M    |           | CHAR may be fixnum or symbol                                         |
  | read(TERM)                   | M/A  | read.pl   | expands into read1/1, which is auto-included                         |
  | read_tokens(TOKENS, VARS)    | A    | rdtok.pl  |                                                                      |
  | recorda(KEY, VAL)            | A    | rdb.pl    |                                                                      |
  | recorda(KEY, VAL, REF)       | A    | rdb.pl    |                                                                      |
  | recorded(KEY, VAL)           | A    | rdb.pl    |                                                                      |
  | recorded(KEY, VAL, REF)      | A    | rdb.pl    |                                                                      |
  | recordz(KEY, VAL)            | A    | rdb.pl    |                                                                      |
  | recordz(KEY, VAL, REF)       | A    | rdb.pl    |                                                                      |
  | repeat                       | S    |           |                                                                      |
  | retract(CLAUSE)              | A    | cdb.pl    |                                                                      |
  | reverse(LST1, LST2)          | A    | lists.pl  |                                                                      |
  | see(FILE)                    | A    | io.pl     | may also pass stream                                                 |
  | seeing(FILE)                 | A    | io.pl     |                                                                      |
  | seen                         | A    | io.pl     | does nothing if stdin                                                |
  | select(ELEM, LIST1, LIST2)   | A    | sets.pl   |                                                                      |
  | set_global(ATOM, X)          | S    |           |                                                                      |
  | shell(COMMAND)               | A    | misc.pl   | expects exit-status 0                                                |
  | shell(COMMAND, STATUS)       | M    |           |                                                                      |
  | skip(C)                      | A    | io.pl     |                                                                      |
  | sleep(SECS)                  | M    |           |                                                                      |
  | sort(S, R)                   | A    | sorts.pl  |                                                                      |
  | stream(X)                    | P    |           |                                                                      |
  | subtract(X, Y, Z)            | A    | sets.pl   |                                                                      |
  | tab(C)                       | A    | io.pl     |                                                                      |
  | tell(FILE)                   | A    | io.pl     | may also pass stream                                                 |
  | telling(STREAM)              | A    | io.pl     |                                                                      |
  | throw(X)                     | A    | misc.pl   | uncatchable, just to signal error                                    |
  | told                         | A    | io.pl     | does nothing if stdout or stderr                                     |
  | true                         | S    |           |                                                                      |
  | union(X, Y, Z)               | A    | sets.pl   |                                                                      |
  | X =.. Y                      | A    | misc.pl   | "univ"                                                               |
  | var(X)                       | P    |           |                                                                      |
  | write(X)                     | A    | write.pl  |                                                                      |
  | writeq(X)                    | A    | write.pl  |                                                                      |
  #+TBLFM: $1=
  - "M" = macro, "A" = autoload, "P" = primitive (in compiler), "S" = special form / builtin
* List of arithmetic operators
  | - X                      |
  | \ X                      |
  | X + Y                    |
  | X - Y                    |
  | X * Y                    |
  | X / Y                    |
  | X // Y                   |
  | X \\ Y                   |
  | X /\ Y                   |
  | X \/ Y                   |
  | X >> Y                   |
  | X << Y                   |
  | X ** Y                   |
  | abs(X)                   |
  | atan(X)                  |
  | ceiling(X)               |
  | cos(X)                   |
  | exp(X)                   |
  | float(X)                 |
  | float_fractional_part(X) |
  | float_integer_part(X)    |
  | floor(X)                 |
  | log(X)                   |
  | random(X)
  | round(X)                 |
  | sign(X)                  |
  | sin(X)                   |
  | sqrt(X)                  |
  | truncate(X)              |
* List of directives
  | global_variable(NAME)    |
  | include(FILENAME)        |
  | initialization GOAL      |
  | op(P, A, N)              |
  | pre_initialization(GOAL) |
* Test suites
** file:/archive/prologsuite.tar.gz
** file:/archive/inriasuite.tar.gz
* Benchmark suites
** http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/prolog/code/bench/
