NOTES											              -*- Org -*-


* TODO Implement simple wrapper generator
  - similar to "bind"
  - "RTYPE NAME(ARGTYPE, ...)", generate .c file with primitive defs
    and a .pl for the wrapper predicates.
  - functions, vars, immutable (const) vars.
* Optimization opportunities
** DONE Check: take advantage of timestamps when binding vars in unify() ?
   - try: when binding two unbound vars, bind the younger one.
   - implemented in branch /bind-younger/ and seems to work, but trail
     reduction is not much.
   - compare benchmark results.
   - does it influence /bagof/ ? (comment in support code suggests
     something about the order in which variables are bound - but that
     may be nonsense)
** writeq/1 could use foreign_call(basic_writeq(X)) for atoms
   - but the name needs to be classified anyway, because of the possibly
     required space in front of it.
** Mode-declarations
   - can probably be used in many ways, but needs more thought.
** Arithmetic
   - deref all vars just once at start.
   - track types, use unboxed math.
** With some sort of type/groundness analysis many primitives can be rewritten to simpler forms
   - functor, arg, name, '=..', etc.
** Matching term in db could be done in C
*** Unify inside db_find/db_next (properly undwinding trail on failure)
    - handling heap-full case on thawing still makes this ugly.
** TODO current_op/3 needs fast path when operator name is known
   - could use single-bucket db, with unififcation inside
     db_find/db_next (provided, we implement matching in file:pc.h)
** Deterministic goal in condition of if-then-else can drop some of the CP dance
   - same for '\\+'/2
   - fail could actually just perform a jump, perhaps redefine FAIL
     temporarily (or use intermediate macro).
** Analyze program before compiling to pseudo-instructions
   - perform determinacy-analysis for all code.
   - in other words: actually take advantage of having a static whole-program compiler.
* Things to test
* Missing features
** TODO Some sort of formatted output would be nice
   - file:code/writef.pl uses those funny succ/2 and plus/3 predicates.
     - see file:code/arith.pl
** TODO once/1
** TODO Builtin to read full atom
   - "read_atom(LENGTH)"
   - much cheaper than reading list.
** TODO Allow user-defined macros
   - directive: ":- macro OLD -> NEW" or something like this.
** TODO Extend numerical operators
   - constants "pi", perhaps "e"
   - "max", "min", "asin", "acos"
* Build options
** Allow static allocation of data-areas
** Allow keeping db-data in GC'd heap
   - freeze/thaw would be just a deep copy.
** Make use of floating-point optional
** Currently imported symbols:
   | Name             | Class |
   |------------------+-------|
   | __ctype_b_loc    | R     |
   | __errno_location | D     |
   | _setjmp          | A     |
   | atan             | O     |
   | atol             | R/O   |
   | ceil             | R/O   |
   | clock_gettime    | D     |
   | close            | D     |
   | cos              | O     |
   | exit             | D     |
   | exp              | O     |
   | fclose           | D     |
   | fflush           | D     |
   | fgetc            | R/A   |
   | floor            | R/O   |
   | fopen            | D     |
   | fprintf          |       |
   | fputc            | R/A   |
   | fputs            |       |
   | free             | -     |
   | ftruncate        |       |
   | fwrite           | R/A   |
   | getenv           | D     |
   | getpid           | D     |
   | log              | O     |
   | longjmp          | A     |
   | malloc           | -     |
   | memcmp           | R     |
   | memcpy           | R     |
   | memset           | R     |
   | mmap             | D     |
   | modf             | O     |
   | munmap           | D     |
   | open             |       |
   | pow              |       |
   | rand             | D     |
   | realloc          | -     |
   | round            | R/O   |
   | sin              | O     |
   | sleep            | D     |
   | sprintf          |       |
   | sqrt             | O     |
   | srand            | D     |
   | stat             | D     |
   | stderr           | R/A   |
   | stdin            | R/A   |
   | stdout           | R/A   |
   | strerror         | D     |
   | strncmp          | R     |
   | strndup          | -     |
   | strtod           |       |
   | strtol           |       |
   | system           | D     |
   | toupper          | R     |
   | trunc            | R/O   |
   | ungetc           | R     |
   Class: R = reimplement, D = drop, O = optional, A = asm impl.
* Diagnostics
** Detect singleton variables
** Report unused predicates
* Once we have a suitable test, compare performance with other implementations
  - SWI, GNU-Prolog, BinProlog
* Issues
** TODO name/2 and functor/3 (and others?) may exceed heap-reserve for large inputs
** DONE [#A] Some tests crash in 32-bit mode
   - apparently "key" in lookup_shared_term() is negative, or overflows.
   - changed to use "unsigned long".
   - run make check once again.
** TODO Reduce memory use in pc
   - seems to build up a lot of choice points.
** TODO 0085-boyer crashes in pi
   - sometimes.
** TODO [#B] Implementation of if-then-else is broken
   - if-then stack gets out of balance, found here:
     call_primitive('->', 2, TERM) :-
	!,
	arg(1, TERM, X), arg(2, TERM, Y),
	execute(X) -> execute(Y). % parsed as (!, ...) -> execute(Y)
   - adding parens around last goal repaired the problem, but still
     this shouldn't happen.
** Erasing a db-entry that is already marked is currently ignored
   - actual deletion will happen on next GC.
   - should we throw an error?
   - note that 0069-cdb deletes twice: first the retract of hello(X)
     and then the abolish of hello/1.
** Handle freezing of db-refs
   - disallow? delete from deleted-items list?
   - what can happen?
   - currently caught by assertion in freeze_term_recursive()
** Using multiple threads is currently not possible
   - all static vars would have to be declared TLS, but these may not
     be statically initialized with non-constants, and this applies to
     many data objects for literals.
** TODO Unbound var in arithmetic expr doesn't show variable name
   - extend var-rep to hold name, in addition to index.
** Reader-error should throw syntax_error(MSG)
** TODO Throw ISO-compliant exceptions everywhere
    - at least as much as possible and sensible.
** TODO Isn't most of the stuff in file:lib/ordset.pl, file:lib/sets.pl determinate?
** TODO file:broken-tests/simple_analyzer.pl broken
    - exhausts heap, regardless of size.
    - seems to trail excessively.
* Interpreter
** TODO Add support for file:dcg.pl 
   - term_expansion/2.
   - but I need a way to hook into consult/1 from file:pi.pl, because
     adding DCG-support to interp seems better.
** TODO Additional predicates
   - listing/1
   - listing/0
     - needs some way to enumerate all predicates (current_predicate/1).
     - can use foreign_call(db_find_bucket(...))
* Test suites
** file:/archive/prologsuite.tar.gz
** file:/archive/inriasuite.tar.gz
