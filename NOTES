NOTES											              -*- Org -*-


* Optimization opportunities
** Singleton variables could get special handling when in argument position
   - unification is a noop, unless nested in another term.
** TODO Implement memberchk/2 as primitive
** writeq/1 could use foreign_call(basic_writeq(X)) for atoms
   - but the name needs to be classified anyway, because of the possibly
     required space in front of it.
** Mode-declarations
   - can probably be used in many ways, but needs more thought.
** TODO Determinacy declarations
   - i.e. ":- determinate(PI)."
   - file:da.pl
   - provide predicate "is_deterministic(EXPR)"
   - add declarations for all library predicates, where appropriate.
   - use determinism-information to find more tailcall-opportunities.
     - propagate mode, depending on called predicate, see:
       compile_ordinary_call in file:compile.pl
** TODO Clause indexing
*** This could even be extended to invoke particular entry-points depending on call-arguments
*** Dispatch on type, fixnum-list or atom-list
    - until no clauses are left or first clause that has a variable as first arg.
    - make sure fixnum-checks take place first.
    - no remaining match can set redo to NULL and fail.
*** Dispatch on atom- or fixnum list via hashing
    - add slot containing hash-code to symbol (created during interning)
    - generate table only for first predicate in list, redo in any of
      the clauses can jump back to dispatch for this block.
** Arithmetic
   - deref all vars just once at start.
   - track types, use unboxed math.
** With some sort of type/groundness analysis many primitives can be rewritten to simpler forms
   - functor, arg, name, '=..', etc.
** Matching term in db could be done in C
*** Unify inside db_find/db_next (properly undwinding trail on failure)
    - handling heap-full case on thawing still makes this ugly.
** TODO current_op/3 needs fast path when operator name is known
   - could use single-bucket db, with unififcation inside
     db_find/db_next (provided, we implement matching in file:pc.h)
** Deterministic goal in condition of if-then-else can drop some of the CP dance
   - same for '\\+'/2
   - fail could actually just perform a jump, perhaps redefine FAIL
     temporarily (or use intermediate macro).
** Analyze program before compiling to pseudo-instructions
   - perform determinacy-analysis for all code.
   - in other words: actually take advantage of having a static whole-program compiler.
* TODO Find proper name
* TODO Move repo to bitbucket
* Benchmark results
** Self-compile, 5 times, average of medium 3 runtimes
   - SWI prolog: 1.30s
   - <2015-01-04 Sun>: 1.79s (unoptimized: 2.38s)
   - <2015-01-05 Mon>: 1.71s (smaller data area sizes)
   - <2015-01-08 Thu>: 1.81s (not sure, probably more work done in compiler)
   - <2015-01-08 Thu>: 1.83s (additional catcher-slot in CP)
* Things to test
** TODO Test on Mac, Windows and R/Pi
** TODO Test in 32-bit mode
** TODO test retract-loop
   - file:tests/0069-cdb.pl
* Missing features
** TODO Add content of PC_INCLUDE_PATH to include-path
** TODO Extend numerical operators
   - constants "pi", perhaps "e"
   - "max", "min", "asin", "acos"
** TODO Allow iterating over all items in a DB
   - needed for listing/0 in pi.
** TODO Make it possible to embed compiled code
    - "suspend(IN, OUT)" saves state and suspends execution.
    - define alternative entry-point via macro and return procedure
      ptr to invoke prolog (similar to BONES).
    - also allow access to global_variables, and (prefixed) access
      function.
** TODO add between/3
  - from: http://www.cs.otago.ac.nz/staffpriv/ok/pllib.htm
  #+BEGIN_SRC prolog
%  Sample implementation.

between(L, U, X) :-
    (   integer(L), integer(U) ->
        (   integer(X) ->
            L =< X, X =< U
        ;   var(X) ->
            L =< U,
            $between(L, U, X)
        ;   $error
        )
    ;   integer(L), integer(X), L > X -> fail
    ;   integer(U), integer(X), X > U -> fail
    ;   $error
    ).

$between(L, L, L) :- !.
$between(L, _, L).
$between(L, U, X) :-
    M is L + 1,
    $between(M, U, X).
  #+END_SRC
* Diagnostics
** Detect singleton variables
** Detect redefinitions of primitives
** Detect undefined predicate calls
** Report unused predicates
** Detect non-contiguous predicates
* Once we have a suitable test, compare performance with other implementations
  - maybe file:tests/0060-crypta.pl
  - SWI, GNU-Prolog, BinProlog
* Issues
** Compiler
*** TODO Somehow disable TRACE in auto-included code
    - library code just produces too much output.
    - perhaps handle this via a directive.
*** TODO Unbound var in arithmetic expr doesn't show variable name
   - extend var-rep to hold name, in addition to index.
*** TODO check fixnum range when emitting literals 
*** TODO show include-messages only in some sort of "verbose" mode
    - gets in the way with pc-autocompile and is not too interesting
      (still, it should be visible)
    - possibly add "-q" option.
** Runtime
*** TODO trail-GC
    - and adjust CP-stack entries accordingly.
    - tricky.
*** TODO Is cycle-checking in =deref= really necessary?
** Libraries
*** TODO reader-errors should go to stderr
*** TODO May a PI (predicate-indicator) be an atom, refering to all available arities?
    - would need to be added to abolish/1.
*** TODO Throw ISO-compliant exceptions everywhere
    - at least as much as possible and sensible.
* Interpreter
** TODO Additional predicates
   - listing
     - needs some way to enumerate all clauses (clause/2 needs
       sufficiently instantiated head).
** TODO Arithmetic evaluation
   - add system predicates that invoke evaluator, generate code for
     dispatching on and evaluating math-ops.
** TODO Handle directives
   - including latent expressions.
** TODO Print variables after query
   - needs access to their original names.
     - should be easy with read/2.
* List of directives
  | global_variable(NAME)    |
  | include(FILENAME)        |
  | initialization GOAL      |
  | op(P, A, N)              |
  | pre_initialization(GOAL) |
  | trace_libraries          |
* list of predefined operators
  | Name             | Associativity | Precedence |
  |------------------+---------------+------------|
  | @=<              | xfx           |        700 |
  | ;                | xfy           |       1100 |
  | @<               | xfx           |        700 |
  | ,                | xfy           |       1000 |
  | is               | xfx           |        700 |
  | **               | xfx           |        200 |
  | @>               | xfx           |        700 |
  | <<               | yfx           |        400 |
  | @>=              | xfx           |        700 |
  | \==              | xfx           |        700 |
  | '^'              | xfy           |        200 |
  | +                | fy            |        200 |
  | +                | yfx           |        500 |
  | >>               | yfx           |        400 |
  | '=='             | xfx           |        700 |
  | -                | fy            |        200 |
  | -                | yfx           |        500 |
  | initialization   | fx            |       1150 |
  | \+               | fy            |        900 |
  | '=:='            | xfx           |        700 |
  | '=\='            | xfx           |        700 |
  | \/               | yfx           |        500 |
  | :-               | fx            |       1200 |
  | :-               | xfx           |       1200 |
  | \=               | xfx           |        700 |
  | \                | fy            |        200 |
  | /\               | yfx           |        500 |
  | xor              | yfx           |        400 |
  | '=<'             | xfx           |        700 |
  | <                | xfx           |        700 |
  | '=..'            | xfx           |        700 |
  | '='              | xfx           |        700 |
  | //               | yfx           |        400 |
  | '/'              | yfx           |        400 |
  | ->               | xfy           |       1050 |
  | >                | xfx           |        700 |
  | '*'              | yfx           |        400 |
  | >=               | xfx           |        700 |
  | -->              | xfx           |       1200 |
  | '                | xfy           |       1105 |
  | \\               | xfy           |        400 |
* Test suites
** file:/archive/prologsuite.tar.gz
** file:/archive/inriasuite.tar.gz
* Usable for tests and/or benchmarks
** TODO Add files from dobry.txt as tests
   - file:boyer.pl, file:chat_parser.pl, file:query.pl,
     file:simple_analyzer.pl, file:unify.pl, file:reducer.pl,
     file:diff.pl
** file:holmer.tgz
** file:ecrc.tgz
* Benchmark suites
** http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/prolog/code/bench/
