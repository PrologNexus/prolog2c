NOTES											              -*- Org -*-


* Issues
** Major
*** TODO Why is so much space accumulating on arg- and env-stacks?
*** TODO 0028-endless-tailcall crashes in pi
    - hits some limit, not sure which.
    - is in any case not keeping the memory-use constant.
*** TODO [#B] Implementation of if-then-else seems to be broken
   - if-then stack gets out of balance, found here:
     call_primitive('->', 2, TERM) :-
	!,
	arg(1, TERM, X), arg(2, TERM, Y),
	execute(X) -> execute(Y). % parsed as (!, ...) -> execute(Y)
   - adding parens around last goal repaired the problem, but still
     this shouldn't happen.
*** 32-bit version can't tokenize fractional part of real if it doesn't fit into an integer
   - e.g.:
     main :- f(0.463647609000806).
*** Everything is still rather slow and uses too much memory
   - see file:broken-tests/
*** Once trail-stack reserve is reached, GC will happen all the time if the trail can't be reduced
*** If heap is insufficient deref_term/3 will loop endlessly
   - also read_atom/2, recorded/X, retract/1 and clause/X
*** name/2 and functor/3 (and others?) may exceed heap-reserve for large inputs
** Minor
*** Failure in term_expansion/2 will simply be ignored
*** The output of TRACE_TAILCALL() is somewhat confusing
    - Not sure if arguments output reflects the correct state.
    - can we get rid of this?
*** Reduce memory use in pc
    - seems to build up a lot of choice points.
*** Erasing a db-entry that is already marked is currently ignored
   - actual deletion will happen on next GC.
   - should we throw an error?
   - note that 0069-cdb deletes twice: first the retract of hello(X)
     and then the abolish of hello/1.
*** Handle freezing of db-refs
   - delete from deleted-items list?
   - what can happen?
   - currently caught by assertion in freeze_term_recursive()
*** Using multiple threads is currently not possible
   - all static vars would have to be declared TLS, but these may not
     be statically initialized with non-constants, and this applies to
     many data objects for literals.
   - but user-defined literals can't be shared, or not?
*** Unbound var in arithmetic expr doesn't show variable name
   - extend var-rep to hold name, in addition to index.
*** Reader-error should throw syntax_error with message argument
*** Throw ISO-compliant exceptions everywhere
    - at least as much as possible and sensible.
*** Isn't most of the stuff in file:lib/ordset.pl, file:lib/sets.pl determinate?
* Optimization opportunities
** Remove unused predicates
   - could be done in assembly-stage
     - register called predicates (and caller), compute unused
       predicates and predicates used by other unused predicates and
       drop sections of pseudo-instructions.
     - add pseudo-instructions for marking start + end of predicate
       definition.
** Peephole optimization of pseudo-instructions
** Environment trimming
   - sort variables by lifetime (reversed) and trim env_top after last use.
   - may only be applicable when env_top didn't change.
** TODO Add "determinate" declarations and green cuts in library code
** Special-case calls of primitives that are known to always succeed
** DONE Take advantage of timestamps when binding vars in unify()
   - implemented in branch /bind-younger/ and seems to work, but trail
     is not slightly smaller.
** writeq/1 could use foreign_call(basic_writeq(X)) for atoms
   - but the name needs to be classified anyway, because of the possibly
     required space in front of it.
** Arithmetic
   - deref all vars just once at start.
   - track types, use unboxed math.
** With some sort of type/groundness analysis many primitives can be rewritten to simpler forms
   - functor, arg, name, univ, etc.
   - atom_codes/2 could fail on full heap, force GC and retry,
     would need to be moved into file:lib/misc.pl
** current_op/3 needs fast path when operator name is known
   - could use single-bucket db, with unififcation inside
     db_find/db_next (provided, we implement matching in file:pc.h)
** Deterministic goal in condition of if-then-else can drop some of the CP dance
   - same for '\\+'/2, once/1
   - fail could actually just perform a jump, perhaps redefine FAIL
     temporarily (or use intermediate macro).
** Analyze program before compiling to pseudo-instructions
   - perform determinacy-analysis for all code.
   - in other words: actually take advantage of having a static whole-program compiler.
* Features
** Show warning for untriggered delayed goals with "-:d"
   - check trail-entries when unwinding trail and before exit.
** Allow access to delay goals
   - frozen(VAR, PTRARGS) :: return ptr/args pairs,
        non-deterministically
** Unicode
   - arbitrary character codes in strings (UTF-8?)
   - atom-length (string_length())
   - extend name/2, get/1, get0/1, put/1, skip/1 (and probably many
     more)
** Allow "library(ATOM)" as file-spec
   - consult/1, include/1, ensure_loaded/1
   - would this simply prepend "lib/"?
** Extend numerical operators
   - constants "pi", perhaps "e"
   - "max", "min", "asin", "acos"
* Documentation
** DONE News
   - string-canonicalization didn't handle empty strings.
   - pb: "-i" option.
   - pb: handling "\" inside text (not followed by WS + NL)
   - pb: fixed handling zero-argument function with result.
   - pb: "/* success */" result modifier.
   - once/1
   - undefined goals in interpreter throw error.
   - slightly faster db-key computation.
   - pi: ensure_loaded/1 directive.
   - added -q option to pi, also added some verbose output when including/consulting.
* Build options
** Allow static allocation of data-areas
   - statically allocated data for all areas.
   - fixed sizes for gap-buffer and string-buffer.
   - would need to put DBs, buckets and items into heap, using bytevectors.
** Allow keeping db-data in GC'd heap
   - freeze/thaw would be just a deep copy.
   - needs to check heap and possibly GC before asserting/recording.
** Make use of floating-point optional
   - see /intmath/ branch.
   - had funny behaviour with pi (use of flonum simple aborts.)
* Diagnostics
** Detect singleton variables
** Report unused predicates
* Tests
** TODO profile with gprof
* Interpreter
** TODO Allow detecting interpreter from running program
   - or find some trick.
   - could simply record some entry in RDB.
** Add "listing"
   - listing/1
   - listing/0
     - needs some way to enumerate all predicates (current_predicate/1).
     - could use foreign_call(db_find_bucket(...))
* Test suites
** file:/archive/prologsuite.tar.gz
** file:/archive/inriasuite.tar.gz
** file:/archive/iclpgcbenches.tar.gz
* Undocumented features
** Compiler
*** '$predicate_address'/2
** Builtins
*** '$call_predicate'/2
** Interpreter
*** expand_term/2 + term_expansion/2
* Release steps
** Document changes
** make fullcheck
** Test on WIN64
** Test on Mac
** Test on [pi], [call-cc]
** Test dist
** Tag, push, upload
** Bump version (file:README + file:version.pl)
