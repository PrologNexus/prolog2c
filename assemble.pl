%%% "asembly" of pseudo-instructions into C


%% assembler entry point

assemble_file(FILE, STATE) :-
	tell(FILE),
	generate_header,
	assemble_literals(STATE, S1),
	default_setting(entry_point, MAIN),
	mangle_name(MAIN, MMAIN),
	gen('#define INIT_GOAL ', MMAIN, '$0\n'),
	assemble_global_variables(0, N),
	gen('int main(int argc, char *argv[]) {\n'),
	gen('global_variable_counter=', N, ';\n'),
	gen('BOILERPLATE;{\n'),
	assemble_instructions(S1),
	gen('}}\n'),
	generate_trailer,
	told.

assemble_global_variables(I, N) :-
	recorded(global_variables, NAME, REF),
	erase(REF),
	gen('#define ', NAME, ' ', I, '\n'),
	I2 is I + 1,
	assemble_global_variables(I2, N).
assemble_global_variables(N, N).

assemble_instructions(STATE) :-
	retract(code(OP)),
	assemble(OP, STATE, S2),
	assemble_instructions(S2).
assemble_instructions(_).

generate_header :-
	recorded(source_file, FILE),
	gen('// GENERATED BY pc FROM ', FILE, '\n'),
	gen('#define COMPILED_PROLOG_PROGRAM\n#include "pc.h"\n').

generate_trailer :-
	gen('// END OF FILE\n').


%% assemble pseudo ops

assemble(enter(NAME, ARITY), S, S) :-
	mangle_name(NAME, MNAME),
	gen('}', MNAME, '$', ARITY, ':{\n'),
	gen('#undef CURRENT_NAME\n#undef CURRENT_ARITY\n#define CURRENT_NAME "'),
	gen(NAME, '"\n#define CURRENT_ARITY ', ARITY, '\nENTER;\n').

assemble(environment(SIZE), S, S) :- gen('ENVIRONMENT(', SIZE, ');\n').
assemble(determinate_exit, S, S) :- gen('DETERMINATE_EXIT;\n').
assemble(exit, S, S) :-	gen('EXIT;\n').
assemble(redo, S, S) :- gen('REDO;\n').

assemble(set_redo(L), S, S) :- gen('SET_REDO(&&', L, ');\n').
assemble(no_redo, S, S) :- gen('SET_REDO(NULL);\n').
assemble(copy_choice_point(L), S, S) :- gen('COPY_CHOICE_POINT(&&', L, ');\n').
assemble(push_choice_point(L), S, S) :- gen('PUSH_CHOICE_POINT(&&', L, ');\n').
assemble(pop_choice_point, S, S) :- gen('POP_CHOICE_POINT;\n').
assemble(save_choice_points, S, S) :- gen('SAVE_CHOICE_POINTS;\n').
assemble(restore_choice_points, S, S) :- gen('RESTORE_CHOICE_POINTS;\n').
assemble(adjust_choice_point(L), S, S) :- gen('ADJUST_CHOICE_POINT(&&', L, ');\n').

assemble(cut, S, S) :- gen('CUT;\n').

assemble(label(LABEL), S, S) :- gen('}', LABEL, ':{\n').
assemble(local(N, R), S, S) :- gen('X ', R, '=E[', N, '];\n').
assemble(unify(R1, R2), S, S) :- gen('if(!unify(', R1, ',', R2, ')) FAIL;\n').
assemble(not_unify(R1, R2), S, S) :- gen('if(unify(', R1, ',', R2, ')) FAIL;\n').
assemble(argument(INDEX, R), S, S) :- gen('X ', R, '=A[', INDEX, '];\n').
assemble(assign(N, R), S, S) :- gen('E[', N, ']=', R, ';\n').
assemble(make_variable(R), S, S) :- gen('X ', R, '=make_var();\n').
assemble(literal(N, R, _), S, S) :- gen('X ', R, '=literal_', N, ';\n').

assemble(make_term(RLIST, R), S, S) :-
	length(RLIST, N),
	N1 is N - 1,
	gen('X ', R, '=make_term(', N1, ','),
	generate_data_list(RLIST),
	gen(');\n').

assemble(make_pair(CAR, CDR, R), S, S) :-
	gen('X ', R, '=make_pair('),
	gen(CAR, ',', CDR, ');\n').

assemble(jump(LABEL), S, S) :- gen('goto ', LABEL, ';\n').
assemble(remove_choice_points, S, S) :- gen('CLEARCP;\n').
assemble(fail, S, S) :- gen('FAIL;\n').
assemble(identical(R1, R2), S, S) :- gen('if(!is_identical(', R1, ',', R2, ')) FAIL;\n').
assemble(not_identical(R1, R2), S, S) :- gen('if(is_identical(', R1, ',', R2, ')) FAIL;\n').
assemble(numerically_equal(R1, R2), S, S) :- gen('if(!is_num_eq(', R1, ',', R2, ')) FAIL;\n').
assemble(numerically_not_equal(R1, R2), S, S) :- gen('if(is_num_eq(', R1, ',', R2, ')) FAIL;\n').
assemble(numerically_greater(R1, R2), S, S) :- gen('if(!is_num_gt(', R1, ',', R2, ')) FAIL;\n').
assemble(numerically_less(R1, R2), S, S) :- gen('if(!is_num_lt(', R1, ',', R2, ')) FAIL;\n').
assemble(numerically_greater_or_equal(R1, R2), S, S) :- gen('if(is_num_lt(', R1, ',', R2, ')) FAIL;\n').
assemble(numerically_less_or_equal(R1, R2), S, S) :- gen('if(is_num_gt(', R1, ',', R2, ')) FAIL;\n').

assemble(call(NAME, RLIST, LABEL), S, S) :-
	length(RLIST, ARITY),
	(ARITY > 0 -> gen('A=arg_top;\n'); true),
	assemble_arguments(RLIST, 0),
	mangle_name(NAME, MNAME),
	gen('R=&&', LABEL, ';\ngoto '),
	gen(MNAME, '$', ARITY),
	gen(';}\n', LABEL, ':{\n').

assemble(determinate_call(NAME, RLIST), S, S) :-
	length(RLIST, ARITY),
	gen('POP_ARGUMENTS;\n'),
	(ARITY > 0 -> gen('A=arg_top;\n'); true),
	assemble_arguments(RLIST, 0),
	mangle_name(NAME, MNAME),
	gen('DETERMINATE_CALL(', MNAME, '$', ARITY, ');\n').

assemble(foreign_call(NAME, 0), S, S) :- gen('if(!', NAME, '(C0)) FAIL;\n').
assemble(foreign_call(NAME, RLIST), S, S) :-
	gen('if(!', NAME, '(C0'),
	generate_foreign_arguments(RLIST),
	gen(')) FAIL;\n').	%XXX doesn't pop

assemble(add(R1, R2, R3), S, S) :- gen('X ', R3, '=num_add(', R1, ','),	gen(R2, ');\n').
assemble(subtract(R1, R2, R3), S, S) :-	gen('X ', R3, '=num_sub(', R1, ','), gen(R2, ');\n').
assemble(multiply(R1, R2, R3), S, S) :-	gen('X ', R3, '=num_mul(', R1, ','), gen(R2, ');\n').
assemble(divide(R1, R2, R3), S, S) :- gen('X ', R3, '=num_div(', R1, ','), gen(R2, ');\n').
assemble(quotient(R1, R2, R3), S, S) :- gen('X ', R3, '=num_quo(', R1, ','), gen(R2, ');\n').
assemble(mod(R1, R2, R3), S, S) :- gen('X ', R3, '=num_mod(', R1, ','), gen(R2, ');\n').
assemble(rem(R1, R2, R3), S, S) :- gen('X ', R3, '=num_rem(', R1, ','), gen(R2, ');\n').
assemble(bitwise_and(R1, R2, R3), S, S) :- gen('X ', R3, '=num_and(', R1, ','), gen(R2, ');\n').
assemble(bitwise_or(R1, R2, R3), S, S) :- gen('X ', R3, '=num_or(', R1, ','), gen(R2, ');\n').
assemble(shift_left(R1, R2, R3), S, S) :- gen('X ', R3, '=num_shl(', R1, ','), gen(R2, ');\n').
assemble(shift_right(R1, R2, R3), S, S) :- gen('X ', R3, '=num_shr(', R1, ','), gen(R2, ');\n').
assemble(exponent(R1, R2, R3), S, S) :- gen('X ', R3, '=num_pow(', R1, ','), gen(R2, ');\n').
assemble(xor(R1, R2, R3), S, S) :- gen('X ', R3, '=num_xor(', R1, ',', R2, ');\n').

assemble(bitwise_not(R1, R2), S, S) :- gen('X ', R2, '=num_not(', R1, ');\n').
assemble(abs(R1, R2), S, S) :- gen('X ', R2, '=num_abs(', R1, ');\n').
assemble(atan(R1, R2), S, S) :- gen('X ', R2, '=num_atan(', R1, ');\n').
assemble(ceiling(R1, R2), S, S) :- gen('X ', R2, '=num_ceiling(', R1, ');\n').
assemble(cos(R1, R2), S, S) :- gen('X ', R2, '=num_cos(', R1, ');\n').
assemble(exp(R1, R2), S, S) :- gen('X ', R2, '=num_exp(', R1, ');\n').
assemble(float(R1, R2), S, S) :- gen('X ', R2, '=num_float(', R1, ');\n').
assemble(float_fractional_part(R1, R2), S, S) :- gen('X ', R2, '=num_frac(', R1, ');\n').
assemble(float_integer_part(R1, R2), S, S) :- gen('X ', R2, '=num_int(', R1, ');\n').
assemble(floor(R1, R2), S, S) :- gen('X ', R2, '=num_floor(', R1, ');\n').
assemble(log(R1, R2), S, S) :- gen('X ', R2, '=num_log(', R1, ');\n').
assemble(round(R1, R2), S, S) :- gen('X ', R2, '=num_round(', R1, ');\n').
assemble(sign(R1, R2), S, S) :- gen('X ', R2, '=num_sign(', R1, ');\n').
assemble(sin(R1, R2), S, S) :- gen('X ', R2, '=num_sin(', R1, ');\n').
assemble(sqrt(R1, R2), S, S) :- gen('X ', R2, '=num_sqrt(', R1, ');\n').
assemble(truncate(R1, R2), S, S) :- gen('X ', R2, '=num_truncate(', R1, ');\n').
assemble(negate(R1, R2), S, S) :- gen('X ', R2, '=num_negate(', R1, ');\n').

assemble(integer(R), S, S) :- gen('if(!is_FIXNUM(deref(', R, '))) FAIL;\n').
assemble(number(R), S, S) :- gen('if(!is_number(deref(', R, '))) FAIL;\n').
assemble(var(R), S, S) :- gen('if(!is_VAR(deref(', R, '))) FAIL;\n').
assemble(nonvar(R), S, S) :- gen('if(is_VAR(deref(', R, '))) FAIL;\n').
assemble(atom(R), S, S) :- gen('if(!is_atom(deref(', R, '))) FAIL;\n').
assemble(atomic(R), S, S) :- gen('if(!is_atomic(deref(', R, '))) FAIL;\n').
assemble(compound(R), S, S) :- gen('if(!is_compound(deref(', R, '))) FAIL;\n').
assemble(float(R), S, S) :- gen('if(!is_FLONUM(deref(', R, '))) FAIL;\n').

assemble(term_less(R1, R2), S, S) :- gen('if(compare_terms(deref(', R1, '),deref(', R2, ')) <= 0) FAIL;\n').
assemble(term_not_less(R1, R2), S, S) :- gen('if(compare_terms(deref(', R1, '),deref(', R2, ')) > 0) FAIL;\n').

assemble(global_ref(NAME, R), S, S) :-
	mangle_name(NAME, MNAME),
	gen('X ', R, '=GLOBAL_REF(', MNAME, ');\n').
assemble(global_set(NAME, R), S, S) :-
	mangle_name(NAME, MNAME),
	gen('GLOBAL_SET(', MNAME, ',', R, ');\n').	

assemble(OP, _, _) :-
	error(['invalid pseudo instruction: ', OP]).


%% assemble list of arguments

assemble_arguments([], _).
assemble_arguments([X|MORE], I) :-
	gen('*(arg_top++)=', X, ';\n'),
	I2 is I + 1,
	assemble_arguments(MORE, I2).


%% generate literal data

assemble_literals(S1, S2) :-
	retract(literal(INDEX, TERM)),
	generate_static_literal(INDEX, TERM, S1, S),
	!, assemble_literals(S, S2). % force tail call
assemble_literals(S, S).

generate_static_literal(I, X, S, S) :-
	integer(X), !,		%XXX check fixnum range
	gen('#define literal_', I, ' word_to_fixnum(', X, ')\n').
generate_static_literal(I, X, S, S) :-
	number(X), !,
	gen('static FLONUM_BLOCK lb', I, '={FLONUM_TAG|sizeof(FLOAT),', X, '};\n'),
	gen('#define literal_', I, ' &lb', I, '\n').
generate_static_literal(I, [], S, S) :-
	!, gen('#define literal_', I, ' END_OF_LIST_VAL\n').
generate_static_literal(I, X, S, S) :-
	atom(X), !,
	mangle_name(X, NAME),
	gen('#ifndef SYMBOL', NAME, '\n'),
	name(X, STRING),
	length(STRING, LEN),
	gen('static STRING_BLOCK lbs', I, '={(STRING_TAG|', LEN, ')+1,{'),
	generate_data_list(STRING),
	gen(',0}};\nstatic SYMBOL_BLOCK lb', I, '={SYMBOL_TAG|3,(X)&lbs', I),
	gen(',PREVIOUS_SYMBOL,END_OF_LIST_VAL};\n#undef PREVIOUS_SYMBOL\n#define PREVIOUS_SYMBOL (X)&lb', I),
	gen('\n#define literal_', I, ' &lb', I, '\n'),
	gen('#define SYMBOL', NAME, ' literal_', I, '\n#else\n'),
	gen('#define literal_', I, ' SYMBOL', NAME, '\n#endif\n').
generate_static_literal(I, [X|Y], S1, S2) :-
	!,
	gensym('p', CAR, S1, S3),
	generate_static_literal(CAR, X, S3, S4),
	gensym('p', CDR, S4, S5),
	generate_static_literal(CDR, Y, S5, S2),
	gen('static BLOCK lb', I, '={PAIR_TAG|2,{literal_', CAR),
	gen(',literal_', CDR, '}};\n'),
	gen('#define literal_', I, ' &lb', I, '\n').
generate_static_literal(I, X, S1, S2) :-
	X =.. [F|ARGS], !,
	gensym('f', IF, S1, S3),
	generate_static_literal(IF, F, S3, S4),
	generate_static_literals(ARGS, 1, IF, IS, S4, S2),
	length(ARGS, ARITY),
	gen('static BLOCK lb', I, '={(STRUCTURE_TAG|', ARITY),
	gen(')+1,{literal_', IF, ','),
	generate_data_list(IS),
	gen('}};\n#define literal_', I, ' &lb', I, '\n').

generate_static_literals([], _, _, [], S, S).
generate_static_literals([X|MORE], I, IF, [IS|IMORE], S1, S2) :-
	atomic_list_concat([IF, '_', I], IS1),
	atomic_list_concat(['literal_', IS1], IS),
	generate_static_literal(IS1, X, S1, S),
	I2 is I + 1,
	generate_static_literals(MORE, I2, IF, IMORE, S, S2).


% output helpers

generate_data_list([]).
generate_data_list([X]) :- gen(X), !.
generate_data_list([X|Y]) :- gen(X,','), generate_data_list(Y).

generate_foreign_arguments([]).
generate_foreign_arguments([X]) :- gen(',deref(', X, ')').
generate_foreign_arguments([X|MORE]) :-
	gen(',deref(', X, ')'),
	generate_foreign_arguments(MORE).
