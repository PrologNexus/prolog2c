%%% "asembly" of pseudo-instructions into C


%% assembler entry point

assemble_file(FILE, STATE) :-
	tell(FILE),
	generate_header,
	assemble_literals(STATE, S1),
	(recorded(initialization_goal, MAIN); default_setting(initialization_goal, MAIN)),
	mangle_name(MAIN, MMAIN),
	gen('#define INIT_GOAL ', MMAIN, '$0\n'),
	gen('int main(int argc, char *argv[]) {\n'),
	gen('BOILERPLATE;{\n'),
	assemble_instructions(S1),
	gen('}}\n'),
	generate_trailer,
	told.

assemble_instructions(STATE) :-
	retract(code(OP)),
	assemble(OP, STATE, S2),
	assemble_instructions(S2).
assemble_instructions(_).

generate_header :-
	recorded(source_file, FILE),
	gen('// GENERATED BY pc FROM ', FILE, '\n#include "pc.h"\n').

generate_trailer :-
	gen('// END OF FILE\n').


%% assemble pseudo ops

assemble(enter(NAME, ARITY), S, S) :-
	mangle_name(NAME, MNAME),
	gen('}', MNAME, '$', ARITY, ':{\n'),
	gen('#undef CURRENT_NAME\n#undef CURRENT_ARITY\n#define CURRENT_NAME "'),
	gen(NAME, '"\n#define CURRENT_ARITY ', ARITY, '\nENTER;\n').

assemble(environment(SIZE), S, S) :- gen('ENVIRONMENT(', SIZE, ');\n').
assemble(exit, S, S) :-	gen('EXIT;\n').
assemble(redo, S, S) :- gen('REDO;\n').

assemble(label(LABEL), S, S) :- gen('}', LABEL, ':{\n').
assemble(local(N, R), S, S) :- gen('X ', R, '=E[', N, '];\n').
assemble(unify(R1, R2), S, S) :- gen('if(!unify(', R1, ',', R2, ')) FAIL;\n').
assemble(not_unify(R1, R2), S, S) :- gen('if(unify(', R1, ',', R2, ')) FAIL;\n').
assemble(argument(INDEX, R), S, S) :- gen('X ', R, '=A[', INDEX, '];\n').
assemble(assign(N, R), S, S) :- gen('E[', N, ']=', R, ';\n').
assemble(make_variable(R), S, S) :- gen('X ', R, '=make_var();\n').
assemble(literal(N, R), S, S) :- gen('X ', R, '=literal_', N, ';\n').

assemble(make_term(RLIST, R), S, S) :-
	length(RLIST, N),
	N1 is N - 1,
	gen('X ', R, '=make_term(', N1, ','),
	generate_data_list(RLIST),
	gen(');\n').

assemble(make_pair(CAR, CDR, R), S, S) :-
	gen('X ', R, '=make_pair('),
	gen(CAR, ',', CDR, ');\n').

% A is still in use, but no calls are made until head-unification has taken place:
assemble(pop_arguments, S, S) :- gen('arg_top-=CURRENT_ARITY;\n').

assemble(add_choice_point(LABEL), S, S) :- gen('PUSHCP(&&', LABEL, ');\n').
assemble(push_choice_points, S, S) :- gen('PUSH((X)C);\n').
assemble(pop_choice_points, S, S) :- gen('POPCP;\n').
assemble(jump(LABEL), S, S) :- gen('goto ', LABEL, ';\n').
assemble(remove_choice_points, S, S) :- gen('CLEARCP;\n').
assemble(fail, S, S) :- gen('FAIL;\n').
assemble(identical(R1, R2), S, S) :- gen('if(!is_identical(', R1, ',', R2, ')) FAIL;\n').
assemble(not_identical(R1, R2), S, S) :- gen('if(is_identical(', R1, ',', R2, ')) FAIL;\n').
assemble(numerically_equal(R1, R2), S, S) :- gen('if(!is_num_eq(', R1, ',', R2, ')) FAIL;\n').
assemble(numerically_not_equal(R1, R2), S, S) :- gen('if(!is_num_eq(', R1, ',', R2, ')) FAIL;\n').
assemble(numerically_greater(R1, R2), S, S) :- gen('if(!is_num_gt(', R1, ',', R2, ')) FAIL;\n').
assemble(numerically_less(R1, R2), S, S) :- gen('if(!is_num_lt(', R1, ',', R2, ')) FAIL;\n').
assemble(numerically_greater_or_equal(R1, R2), S, S) :- gen('if(is_num_lt(', R1, ',', R2, ')) FAIL;\n').
assemble(numerically_less_or_equal(R1, R2), S, S) :- gen('if(is_num_gt(', R1, ',', R2, ')) FAIL;\n').

assemble(call(NAME, RLIST, LABEL), S, S) :-
	length(RLIST, ARITY),
	(ARITY > 0 -> gen('A=arg_top;\n'); true),
	assemble_arguments(RLIST, 0),
	mangle_name(NAME, MNAME),
	gen('R0=&&', LABEL, ';\ngoto '),
	gen(MNAME, '$', ARITY),
	gen(';}\n', LABEL, ':{\n').

assemble(tailcall(NAME, RLIST), S, S) :-
	length(RLIST, ARITY),
	assemble_arguments(RLIST, 0),
	mangle_name(NAME, MNAME),
	% args are not popped - this has already being done by cut (or this
	% is the last clause)
	gen('R0=R;\nPOP(env_top);\nPOP(A);\nPOP(E);\nPOP(R);\nPOP(C0);\ngoto ', MNAME),
	gen('$', ARITY, ';\n').

assemble(foreign_call(NAME, 0), S, S) :- gen('if(!', NAME, '()) FAIL;\n').
assemble(foreign_call(NAME, RLIST), S, S) :-
	gen('if(!', NAME, '('),
	generate_foreign_arguments(RLIST),
	gen(')) FAIL;\n').	%XXX doesn't pop

assemble(add(R1, R2, R3), S, S) :-
	gen('X ', R3, '=num_add(', R1, ','),
	gen(R2, ');\n').
assemble(subtract(R1, R2, R3), S, S) :-
	gen('X ', R3, '=num_sub(', R1, ','),
	gen(R2, ');\n').
assemble(multiply(R1, R2, R3), S, S) :-
	gen('X ', R3, '=num_mul(', R1, ','),
	gen(R2, ');\n').
assemble(divide(R1, R2, R3), S, S) :- gen(R3, '=num_div(', R1, ','), gen(R2, ');\n').

assemble(integer(R), S, S) :- gen('if(!is_FIXNUM(deref(', R, '))) FAIL;\n').
assemble(number(R), S, S) :- gen('if(!is_number(deref(', R, '))) FAIL;\n').
assemble(var(R), S, S) :- gen('if(!is_VAR(deref(', R, '))) FAIL;\n').
assemble(nonvar(R), S, S) :- gen('if(is_VAR(deref(', R, '))) FAIL;\n').
assemble(atom(R), S, S) :- gen('if(!is_SYMBOL(deref(', R, '))) FAIL;\n').
assemble(atomic(R), S, S) :- gen('if(!is_atomic(deref(', R, '))) FAIL;\n').
assemble(compound(R), S, S) :- gen('if(!is_compound(deref(', R, '))) FAIL;\n').
assemble(float(R), S, S) :- gen('if(!is_FLONUM(deref(', R, '))) FAIL;\n').

assemble(OP, _, _) :-
	error(['invalid pseudo instruction: ', OP]).


%% assemble list of arguments

assemble_arguments([], _).
assemble_arguments([X|MORE], I) :-
	gen('*(arg_top++)=', X, ';\n'),
	I2 is I + 1,
	assemble_arguments(MORE, I2).


%% generate literal data

assemble_literals(S1, S2) :-
	retract(literal(INDEX, TERM)),
	generate_static_literal(INDEX, TERM, S1, S),
	!, assemble_literals(S, S2). % force tail call
assemble_literals(S, S).

generate_static_literal(I, X, S, S) :-
	integer(X), !,		%XXX check fixnum range
	gen('#define literal_', I, ' word_to_fixnum(', X, ')\n').
generate_static_literal(I, X, S, S) :-
	number(X), !,
	gen('static FLONUM_BLOCK lb', I, '={FLONUM_TAG|sizeof(FLOAT),', X, '};\n'),
	gen('#define literal_', I, ' &lb', I, '\n').
generate_static_literal(I, [], S, S) :-
	!, gen('#define literal_', I, ' END_OF_LIST_VAL\n').
generate_static_literal(I, X, S, S) :-
	atom(X), !,
	mangle_name(X, NAME),
	gen('#ifndef SYMBOL', NAME, '\n'),
	name(X, STRING),
	length(STRING, LEN),
	gen('static STRING_BLOCK lbs', I, '={STRING_TAG|', LEN, '+1,{'),
	generate_data_list(STRING),
	gen(',0}};\nstatic SYMBOL_BLOCK lb', I, '={SYMBOL_TAG|3,(X)&lbs', I),
	gen(',PREVIOUS_SYMBOL,END_OF_LIST_VAL};\n#undef PREVIOUS_SYMBOL\n#define PREVIOUS_SYMBOL (X)&lb', I),
	gen('\n#define literal_', I, ' &lb', I, '\n'),
	gen('#define SYMBOL', NAME, ' literal_', I, '\n#else\n'),
	gen('#define literal_', I, ' SYMBOL', NAME, '\n#endif\n').
generate_static_literal(I, [X|Y], S1, S2) :-
	!,
	gensym('p', CAR, S1, S3),
	generate_static_literal(CAR, X, S3, S4),
	gensym('p', CDR, S4, S5),
	generate_static_literal(CDR, Y, S5, S2),
	gen('static BLOCK lb', I, '={PAIR_TAG|2,{literal_', CAR),
	gen(',literal_', CDR, '}};\n'),
	gen('#define literal_', I, ' &lb', I, '\n').
generate_static_literal(I, X, S1, S2) :-
	X =.. [F|ARGS], !,
	gensym('f', IF, S1, S3),
	generate_static_literal(IF, F, S3, S4),
	generate_static_literals(ARGS, 1, IF, IS, S4, S2),
	length(ARGS, ARITY),
	gen('static BLOCK lb', I, '={STRUCTURE_TAG|', ARITY),
	gen('+1,{literal_', IF, ','),
	generate_data_list(IS),
	gen('}};\n#define literal_', I, ' &lb', I, '\n').

generate_static_literals([], _, _, [], S, S).
generate_static_literals([X|MORE], I, IF, [IS|IMORE], S1, S2) :-
	atomic_list_concat([IF, '_', I], IS1),
	atomic_list_concat(['literal_', IS1], IS),
	generate_static_literal(IS1, X, S1, S),
	I2 = I + 1,
	generate_static_literals(MORE, I2, IF, IMORE, S, S2).


% output helpers

generate_data_list([]).
generate_data_list([X]) :- gen(X), !.
generate_data_list([X|Y]) :- gen(X,','), generate_data_list(Y).

generate_foreign_arguments([]).
generate_foreign_arguments([X]) :- gen('deref(', X, ')').
generate_foreign_arguments([X|MORE]) :-
	gen(',deref(', X, ')'),
	assemble_foreign_arguments(MORE).
